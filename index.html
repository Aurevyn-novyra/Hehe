<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Universe</title>
    <style>
        /* Global reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Fullscreen canvas for all animations */
        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI overlay for buttons and text */
        #uiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* Centered container for scene elements */
        .scene-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
        }

        /* Scene 1 intro text styling */
        #introText {
            color: #fff;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 300;
            letter-spacing: 2px;
            opacity: 0;
            animation: fadeIn 2s ease-in forwards;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        /* Pulsing mystery button */
        #mysteryButton {
            margin-top: 3rem;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            color: #fff;
            background: linear-gradient(45deg, #8b5cf6, #ec4899);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            opacity: 0;
            animation: fadeIn 2s ease-in 1s forwards, pulse 2s infinite;
            transition: transform 0.3s ease;
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
        }

        #mysteryButton:hover {
            transform: scale(1.1);
        }

        #mysteryButton:active {
            transform: scale(0.95);
        }

        /* Continue button for poem scene */
        #continueButton {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.8rem 2.5rem;
            font-size: 1rem;
            color: #fff;
            background: rgba(139, 92, 246, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #continueButton:hover {
            background: rgba(139, 92, 246, 1);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.8);
        }

        /* Poem text styling */
        #poemText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            color: #fff;
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            line-height: 1.8;
            font-weight: 300;
            letter-spacing: 1px;
            pointer-events: none;
        }

        .poem-line {
            opacity: 0;
            margin: 0.5rem 0;
        }

        /* Proposal text and buttons */
        #proposalText {
            color: #fff;
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 300;
            margin-bottom: 3rem;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
        }

        .proposal-buttons {
            display: flex;
            gap: 2rem;
            justify-content: center;
        }

        .proposal-button {
            padding: 1rem 3rem;
            font-size: 1.5rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #yesButton {
            background: linear-gradient(45deg, #10b981, #34d399);
            color: #fff;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }

        #yesButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.8);
        }

        #noButton {
            background: linear-gradient(45deg, #ef4444, #f87171);
            color: #fff;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
            position: relative;
        }

        /* Animations */
        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
            }
            50% {
                box-shadow: 0 0 50px rgba(139, 92, 246, 0.8);
            }
        }

        /* Hide elements by default */
        .hidden {
            display: none !important;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .proposal-buttons {
                flex-direction: column;
                gap: 1rem;
            }
            
            .proposal-button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- Main canvas for all scene animations -->
    <canvas id="mainCanvas"></canvas>
    
    <!-- UI overlay for text and buttons -->
    <div id="uiOverlay">
        <!-- Scene 1: Intro -->
        <div id="scene1" class="scene-container">
            <div id="introText">This isn't a normal websiteâ€¦</div>
            <button id="mysteryButton">Tap Me</button>
        </div>

        <!-- Scene 3: Poem -->
        <div id="scene3" class="scene-container hidden">
            <div id="poemText"></div>
            <button id="continueButton">Continue</button>
        </div>

        <!-- Scene 4: Build Up -->
        <div id="scene4" class="scene-container hidden">
            <button id="lastThingButton">One Last Thingâ€¦</button>
        </div>

        <!-- Scene 6: Proposal -->
        <div id="scene6" class="scene-container hidden">
            <div id="proposalText">Will you be my universe? ðŸ’«</div>
            <div class="proposal-buttons">
                <button id="yesButton" class="proposal-button">YES</button>
                <button id="noButton" class="proposal-button">NO</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            autoAdvanceTime: 10000, // 10 seconds
            starCount: 200,
            tulipCount: 15,
            particleCount: 50,
            canvasWidth: window.innerWidth,
            canvasHeight: window.innerHeight
        };

        // ==================== AUDIO SYSTEM ====================
        class AudioSystem {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.init();
            }

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (error) {
                    console.warn('Audio context failed to initialize:', error);
                }
            }

            createSounds() {
                // Ambient wind loop
                this.sounds.wind = this.createWindSound();
                
                // Slow heartbeat bass
                this.sounds.heartbeat = this.createHeartbeatSound();
                
                // Whoosh transition
                this.sounds.whoosh = this.createWhooshSound();
                
                // Romantic chime
                this.sounds.chime = this.createChimeSound();
            }

            createWindSound() {
                return () => {
                    try {
                        const bufferSize = 2 * this.audioContext.sampleRate;
                        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        
                        // Generate pink noise
                        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                        for (let i = 0; i < bufferSize; i++) {
                            const white = Math.random() * 2 - 1;
                            b0 = 0.99886 * b0 + white * 0.0555179;
                            b1 = 0.99332 * b1 + white * 0.0750759;
                            b2 = 0.96900 * b2 + white * 0.1538520;
                            b3 = 0.86650 * b3 + white * 0.3104856;
                            b4 = 0.55000 * b4 + white * 0.5329522;
                            b5 = -0.7616 * b5 - white * 0.0168980;
                            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.05;
                            b6 = white * 0.115926;
                        }

                        const whiteNoise = this.audioContext.createBufferSource();
                        whiteNoise.buffer = noiseBuffer;
                        whiteNoise.loop = true;

                        const filter = this.audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 200;
                        filter.Q.value = 1;

                        const gainNode = this.audioContext.createGain();
                        gainNode.gain.value = 0.1;

                        whiteNoise.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);

                        whiteNoise.start();
                        return { source: whiteNoise, gain: gainNode };
                    } catch (error) {
                        console.warn('Wind sound creation failed:', error);
                        return null;
                    }
                };
            }

            createHeartbeatSound() {
                return () => {
                    try {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 40;
                        gainNode.gain.value = 0;
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.start();
                        
                        // Create heartbeat rhythm
                        const beat = () => {
                            const now = this.audioContext.currentTime;
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                            setTimeout(() => {
                                const now2 = this.audioContext.currentTime;
                                gainNode.gain.setValueAtTime(0, now2);
                                gainNode.gain.linearRampToValueAtTime(0.2, now2 + 0.01);
                                gainNode.gain.exponentialRampToValueAtTime(0.01, now2 + 0.15);
                            }, 300);
                        };
                        
                        beat();
                        const interval = setInterval(beat, 1000);
                        return { source: oscillator, gain: gainNode, interval };
                    } catch (error) {
                        console.warn('Heartbeat sound creation failed:', error);
                        return null;
                    }
                };
            }

            createWhooshSound() {
                return () => {
                    try {
                        const bufferSize = this.audioContext.sampleRate * 0.5;
                        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / bufferSize * 5);
                        }
                        
                        const source = this.audioContext.createBufferSource();
                        source.buffer = buffer;
                        
                        const filter = this.audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(100, this.audioContext.currentTime);
                        filter.frequency.exponentialRampToValueAtTime(2000, this.audioContext.currentTime + 0.5);
                        
                        const gainNode = this.audioContext.createGain();
                        gainNode.gain.value = 0.3;
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                        
                        source.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        source.start();
                        return { source, gain: gainNode };
                    } catch (error) {
                        console.warn('Whoosh sound creation failed:', error);
                        return null;
                    }
                };
            }

            createChimeSound() {
                return () => {
                    try {
                        const frequencies = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
                        const startTime = this.audioContext.currentTime;
                        
                        frequencies.forEach((freq, index) => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.value = freq;
                            
                            const now = startTime + index * 0.1;
                            gainNode.gain.setValueAtTime(0, now);
                            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start(now);
                            oscillator.stop(now + 1.5);
                        });
                    } catch (error) {
                        console.warn('Chime sound creation failed:', error);
                    }
                };
            }

            play(soundName) {
                if (!this.audioContext) return;
                
                try {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    const sound = this.sounds[soundName];
                    if (sound) {
                        return sound();
                    }
                } catch (error) {
                    console.warn(`Failed to play ${soundName}:`, error);
                }
            }

            stop(soundInstance) {
                if (soundInstance) {
                    try {
                        if (soundInstance.interval) {
                            clearInterval(soundInstance.interval);
                        }
                        if (soundInstance.source) {
                            soundInstance.source.stop();
                        }
                    } catch (error) {
                        console.warn('Failed to stop sound:', error);
                    }
                }
            }
        }

        // ==================== PARTICLE SYSTEM ====================
        class Particle {
            constructor(x, y, color, velocity) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity || {
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8
                };
                this.life = 1;
                this.decay = Math.random() * 0.02 + 0.01;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.velocity.y += 0.1; // gravity
                this.velocity.x *= 0.99; // friction
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // ==================== TULIP CLASS ====================
        class Tulip {
            constructor(x, y, scale, depth) {
                this.x = x;
                this.y = y;
                this.scale = scale;
                this.depth = depth; // 0 = front, 1 = back
                this.swayOffset = Math.random() * Math.PI * 2;
                this.petalLayers = 3;
            }

            draw(ctx, time) {
                ctx.save();
                
                // Apply depth-based transformations
                const depthScale = 1 - this.depth * 0.5;
                const depthAlpha = 1 - this.depth * 0.4;
                const sway = Math.sin(time * 0.001 + this.swayOffset) * (1 - this.depth) * 5;
                
                ctx.translate(this.x + sway, this.y);
                ctx.scale(this.scale * depthScale, this.scale * depthScale);
                ctx.globalAlpha = depthAlpha;

                // Draw stem with bezier curve
                this.drawStem(ctx);
                
                // Draw leaves
                this.drawLeaves(ctx);
                
                // Draw flower head with layered petals
                this.drawFlowerHead(ctx);
                
                // Draw shadow
                this.drawShadow(ctx, time);
                
                ctx.restore();
            }

            drawStem(ctx) {
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(-5, -30, -3, -60);
                ctx.quadraticCurveTo(0, -80, 0, -100);
                ctx.stroke();
            }

            drawLeaves(ctx) {
                // Left leaf
                ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
                ctx.beginPath();
                ctx.ellipse(-15, -40, 8, 20, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Right leaf
                ctx.beginPath();
                ctx.ellipse(15, -50, 8, 20, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
            }

            drawFlowerHead(ctx) {
                const centerY = -120;
                const colors = [
                    ['#fbbf24', '#f59e0b', '#d97706'], // Yellow-orange gradient
                    ['#ec4899', '#db2777', '#be185d'], // Pink gradient
                    ['#a78bfa', '#8b5cf6', '#7c3aed']  // Purple gradient
                ];
                const colorSet = colors[Math.floor(Math.random() * colors.length)];

                // Draw layered petals
                for (let layer = 0; layer < this.petalLayers; layer++) {
                    const petalCount = 6 + layer * 2;
                    const radius = 20 + layer * 8;
                    const gradient = ctx.createRadialGradient(0, centerY, 0, 0, centerY, radius);
                    
                    if (layer === 0) {
                        gradient.addColorStop(0, colorSet[0]);
                        gradient.addColorStop(1, colorSet[1]);
                    } else {
                        gradient.addColorStop(0, colorSet[1]);
                        gradient.addColorStop(1, colorSet[2]);
                    }

                    ctx.fillStyle = gradient;
                    
                    for (let i = 0; i < petalCount; i++) {
                        const angle = (i / petalCount) * Math.PI * 2;
                        const petalX = Math.cos(angle) * radius;
                        const petalY = centerY + Math.sin(angle) * radius;
                        
                        ctx.save();
                        ctx.translate(petalX, petalY);
                        ctx.rotate(angle);
                        
                        // Draw petal shape
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(-5, -10, 0, -15);
                        ctx.quadraticCurveTo(5, -10, 0, 0);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }

                // Draw center
                const centerGradient = ctx.createRadialGradient(0, centerY, 0, 0, centerY, 10);
                centerGradient.addColorStop(0, '#fef3c7');
                centerGradient.addColorStop(1, '#fbbf24');
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(0, centerY, 10, 0, Math.PI * 2);
                ctx.fill();
            }

            drawShadow(ctx, time) {
                ctx.save();
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = '#000';
                const sway = Math.sin(time * 0.001 + this.swayOffset) * 2;
                ctx.beginPath();
                ctx.ellipse(sway, 10, 30 * this.scale, 10 * this.scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ==================== SCENE MANAGER ====================
        class SceneManager {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentScene = 1;
                this.animationId = null;
                this.particles = [];
                this.tulips = [];
                this.stars = [];
                this.audio = new AudioSystem();
                this.autoAdvanceTimer = null;
                
                this.resizeCanvas();
                this.initializeScene1();
                this.bindEvents();
                this.startAnimationLoop();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                CONFIG.canvasWidth = window.innerWidth;
                CONFIG.canvasHeight = window.innerHeight;
            }

            bindEvents() {
                // Handle window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Scene 1: Mystery button
                document.getElementById('mysteryButton').addEventListener('click', () => this.transitionToScene2());
                document.getElementById('mysteryButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.transitionToScene2();
                });
                
                // Scene 3: Continue button
                document.getElementById('continueButton').addEventListener('click', () => this.showNextPoemLines());
                document.getElementById('continueButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.showNextPoemLines();
                });
                
                // Scene 4: Last thing button
                document.getElementById('lastThingButton').addEventListener('click', () => this.transitionToScene5());
                document.getElementById('lastThingButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.transitionToScene5();
                });
                
                // Scene 6: Proposal buttons
                document.getElementById('yesButton').addEventListener('click', () => this.handleYes());
                document.getElementById('yesButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleYes();
                });
                
                document.getElementById('noButton').addEventListener('mouseenter', () => this.dodgeNoButton());
                document.getElementById('noButton').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.dodgeNoButton();
                });
                
                // Auto-advance fallback
                this.setAutoAdvance();
            }

            setAutoAdvance() {
                this.clearAutoAdvance();
                this.autoAdvanceTimer = setTimeout(() => {
                    this.handleAutoAdvance();
                }, CONFIG.autoAdvanceTime);
            }

            clearAutoAdvance() {
                if (this.autoAdvanceTimer) {
                    clearTimeout(this.autoAdvanceTimer);
                    this.autoAdvanceTimer = null;
                }
            }

            handleAutoAdvance() {
                switch (this.currentScene) {
                    case 1:
                        this.transitionToScene2();
                        break;
                    case 3:
                        if (this.poemLineIndex < this.poemLines.length) {
                            this.showNextPoemLines();
                        } else {
                            this.transitionToScene4();
                        }
                        break;
                    case 4:
                        this.transitionToScene5();
                        break;
                }
            }

            // ==================== SCENE 1: INTRO ====================
            initializeScene1() {
                try {
                    // Generate starfield
                    this.stars = [];
                    for (let i = 0; i < CONFIG.starCount; i++) {
                        this.stars.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            size: Math.random() * 2 + 0.5,
                            speed: Math.random() * 0.5 + 0.1,
                            opacity: Math.random() * 0.8 + 0.2
                        });
                    }
                    
                    // Start ambient sounds
                    this.windSound = this.audio.play('wind');
                    this.heartbeatSound = this.audio.play('heartbeat');
                    
                } catch (error) {
                    console.warn('Scene 1 initialization failed:', error);
                }
            }

            drawScene1(ctx) {
                // Clear canvas with deep black
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Add subtle purple fog overlay
                const fogGradient = ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2
                );
                fogGradient.addColorStop(0, 'rgba(139, 92, 246, 0.1)');
                fogGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = fogGradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Animate stars
                ctx.fillStyle = '#fff';
                this.stars.forEach(star => {
                    ctx.globalAlpha = star.opacity;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Move stars
                    star.y -= star.speed;
                    if (star.y < 0) {
                        star.y = this.canvas.height;
                        star.x = Math.random() * this.canvas.width;
                    }
                });
                ctx.globalAlpha = 1;
            }

            // ==================== SCENE TRANSITION: 1 TO 2 ====================
            transitionToScene2() {
                try {
                    this.clearAutoAdvance();
                    this.currentScene = 2;
                    
                    // Play whoosh sound
                    this.audio.play('whoosh');
                    
                    // Disintegrate button into particles
                    const button = document.getElementById('mysteryButton');
                    const rect = button.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // Create particles from button
                    for (let i = 0; i < CONFIG.particleCount; i++) {
                        this.particles.push(new Particle(centerX, centerY, '#8b5cf6'));
                    }
                    
                    // Hide UI
                    document.getElementById('scene1').classList.add('hidden');
                    
                    // Initialize tulip garden
                    this.initializeScene2();
                    
                } catch (error) {
                    console.warn('Transition to scene 2 failed:', error);
                    this.fallbackToScene2();
                }
            }

            fallbackToScene2() {
                // Direct transition if animation fails
                this.currentScene = 2;
                document.getElementById('scene1').classList.add('hidden');
                this.initializeScene2();
            }

            // ==================== SCENE 2: TULIP GARDEN ====================
            initializeScene2() {
                try {
                    // Generate tulips with depth
                    this.tulips = [];
                    for (let i = 0; i < CONFIG.tulipCount; i++) {
                        const depth = Math.random();
                        const scale = 0.5 + (1 - depth) * 0.8; // Bigger in front
                        const x = Math.random() * this.canvas.width;
                        const y = this.canvas.height - Math.random() * 200 - 100;
                        
                        this.tulips.push(new Tulip(x, y, scale, depth));
                    }
                    
                    // Sort by depth for proper rendering
                    this.tulips.sort((a, b) => b.depth - a.depth);
                    
                    // Auto-advance after viewing
                    this.setAutoAdvance();
                    
                } catch (error) {
                    console.warn('Scene 2 initialization failed:', error);
                }
            }

            drawScene2(ctx, time) {
                // Clear canvas
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw ground
                const groundGradient = ctx.createLinearGradient(0, this.canvas.height - 100, 0, this.canvas.height);
                groundGradient.addColorStop(0, '#1e293b');
                groundGradient.addColorStop(1, '#0f172a');
                ctx.fillStyle = groundGradient;
                ctx.fillRect(0, this.canvas.height - 100, this.canvas.width, 100);
                
                // Draw tulips
                this.tulips.forEach(tulip => tulip.draw(ctx, time));
                
                // Update particles from transition
                this.updateParticles(ctx);
                
                // Check if should auto-advance to poem
                if (this.particles.length === 0 && !this.scene2Timer) {
                    this.scene2Timer = setTimeout(() => {
                        this.transitionToScene3();
                    }, 3000);
                }
            }

            // ==================== SCENE 3: POEM ====================
            transitionToScene3() {
                try {
                    this.clearAutoAdvance();
                    this.currentScene = 3;
                    
                    // Hide canvas and show poem UI
                    this.canvas.style.opacity = '0';
                    document.getElementById('scene3').classList.remove('hidden');
                    
                    // Initialize poem
                    this.poemLines = [
                        "Sometimes I think I fell for you",
                        "before I even learned how falling works.",
                        "My words trip over themselves..",
                        "And as I said earlier.. you're like a Luminous Singularity",
                        "which's parallel yet coincidently intersecting...",
                        "Like constellations shuffled in a hurry...",
                        "Orion losing its belt..",
                        "Cassiopeia sitting upside down..",
                        "and whole sky is asking \"Why is she the only one shining this bright?\"",
                        "And I swear ...",
                        "every time i try to explain what you mean to me.. I fumble..I'm scared...",
                        "and my heart chooses Your tulips instead of sentences",
                        "petals arranged in a wrong order.. yet beautiful..",
                        "Colors mixing where they shouldn't yet somehow looking eternal..",
                        "and it's strange how You make the universe feel like a misprinted bouquet..",
                        "Galaxies scribbled over with your name..",
                        "planets orbiting a little too close..",
                        "a pull like the Black hole..",
                        "Like they too forgot their distance.",
                        "And me? I'm jst a boy holding a bouquet thinking maybe if I say it wrong enough times",
                        "you Might hear the truth hidden between the mistakes",
                        "That in every star's cold shimmer and every tulip's quite softness",
                        "i keep finding you",
                        "not perfectly..",
                        "not clearly",
                        "but completely..."
                    ];
                    this.poemLineIndex = 0;
                    this.currentPoemLines = [];
                    
                    this.setAutoAdvance();
                    
                } catch (error) {
                    console.warn('Transition to scene 3 failed:', error);
                }
            }

            showNextPoemLines() {
                try {
                    this.clearAutoAdvance();
                    
                    const poemText = document.getElementById('poemText');
                    const continueButton = document.getElementById('continueButton');
                    
                    // Hide continue button during animation
                    continueButton.style.opacity = '0';
                    
                    // Show next two lines
                    const linesToShow = [];
                    for (let i = 0; i < 2 && this.poemLineIndex < this.poemLines.length; i++) {
                        linesToShow.push(this.poemLines[this.poemLineIndex]);
                        this.poemLineIndex++;
                    }
                    
                    // Create line elements with typewriter effect
                    linesToShow.forEach((line, index) => {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'poem-line';
                        lineElement.textContent = line;
                        poemText.appendChild(lineElement);
                        
                        // Trigger reflow for animation
                        lineElement.offsetHeight;
                        
                        // Fade in with delay
                        setTimeout(() => {
                            lineElement.style.transition = 'opacity 1s ease';
                            lineElement.style.opacity = '1';
                        }, index * 500);
                    });
                    
                    // Show continue button after lines appear
                    setTimeout(() => {
                        if (this.poemLineIndex < this.poemLines.length) {
                            continueButton.style.opacity = '1';
                        } else {
                            // All lines shown, transition to next scene
                            continueButton.textContent = 'One Last Thingâ€¦';
                            continueButton.onclick = () => this.transitionToScene4();
                            continueButton.ontouchstart = (e) => {
                                e.preventDefault();
                                this.transitionToScene4();
                            };
                            continueButton.style.opacity = '1';
                        }
                        this.setAutoAdvance();
                    }, linesToShow.length * 500 + 1000);
                    
                } catch (error) {
                    console.warn('Show poem lines failed:', error);
                }
            }

            // ==================== SCENE 4: BUILD UP ====================
            transitionToScene4() {
                try {
                    this.clearAutoAdvance();
                    this.currentScene = 4;
                    
                    // Hide poem scene
                    document.getElementById('scene3').classList.add('hidden');
                    
                    // Show last thing button
                    document.getElementById('scene4').classList.remove('hidden');
                    
                    // Restore canvas opacity
                    this.canvas.style.opacity = '1';
                    
                    this.setAutoAdvance();
                    
                } catch (error) {
                    console.warn('Transition to scene 4 failed:', error);
                }
            }

            // ==================== SCENE 5: BOUQUET ====================
            transitionToScene5() {
                try {
                    this.clearAutoAdvance();
                    this.currentScene = 5;
                    
                    // Hide UI
                    document.getElementById('scene4').classList.add('hidden');
                    
                    // Play whoosh sound
                    this.audio.play('whoosh');
                    
                    // Animate tulips into bouquet
                    this.bouquetAnimation = {
                        progress: 0,
                        duration: 3000,
                        startTime: Date.now()
                    };
                    
                    // Define bouquet target position
                    this.bouquetTarget = {
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2
                    };
                    
                } catch (error) {
                    console.warn('Transition to scene 5 failed:', error);
                    this.fallbackToScene6();
                }
            }

            drawScene5(ctx, time) {
                // Clear canvas
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Calculate animation progress
                const elapsed = Date.now() - this.bouquetAnimation.startTime;
                const progress = Math.min(elapsed / this.bouquetAnimation.duration, 1);
                
                // Draw tulips moving to bouquet position
                this.tulips.forEach((tulip, index) => {
                    const delay = index * 100;
                    const tulipProgress = Math.max(0, Math.min(1, (elapsed - delay) / (this.bouquetAnimation.duration - delay)));
                    
                    // Interpolate position
                    const startX = tulip.x;
                    const startY = tulip.y;
                    const targetX = this.bouquetTarget.x + (index - this.tulips.length / 2) * 30;
                    const targetY = this.bouquetTarget.y;
                    
                    const currentX = startX + (targetX - startX) * tulipProgress;
                    const currentY = startY + (targetY - startY) * tulipProgress;
                    
                    // Temporarily update tulip position for drawing
                    const originalX = tulip.x;
                    const originalY = tulip.y;
                    tulip.x = currentX;
                    tulip.y = currentY;
                    
                    // Draw tulip
                    tulip.draw(ctx, time);
                    
                    // Restore original position
                    tulip.x = originalX;
                    tulip.y = originalY;
                });
                
                // Draw ribbon if animation complete
                if (progress >= 1) {
                    this.drawRibbon(ctx);
                    setTimeout(() => this.transitionToScene6(), 1000);
                }
                
                this.updateParticles(ctx);
            }

            drawRibbon(ctx) {
                try {
                    ctx.save();
                    ctx.strokeStyle = '#dc2626';
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    
                    // Draw ribbon wrapping around bouquet
                    ctx.beginPath();
                    ctx.moveTo(this.bouquetTarget.x - 60, this.bouquetTarget.y - 30);
                    ctx.quadraticCurveTo(this.bouquetTarget.x, this.bouquetTarget.y - 50, this.bouquetTarget.x + 60, this.bouquetTarget.y - 30);
                    ctx.quadraticCurveTo(this.bouquetTarget.x, this.bouquetTarget.y - 10, this.bouquetTarget.x - 60, this.bouquetTarget.y - 30);
                    ctx.stroke();
                    
                    // Draw bow
                    ctx.beginPath();
                    ctx.moveTo(this.bouquetTarget.x - 20, this.bouquetTarget.y - 50);
                    ctx.quadraticCurveTo(this.bouquetTarget.x - 10, this.bouquetTarget.y - 70, this.bouquetTarget.x, this.bouquetTarget.y - 60);
                    ctx.quadraticCurveTo(this.bouquetTarget.x + 10, this.bouquetTarget.y - 70, this.bouquetTarget.x + 20, this.bouquetTarget.y - 50);
                    ctx.stroke();
                    
                    ctx.restore();
                } catch (error) {
                    console.warn('Ribbon drawing failed:', error);
                }
            }

            // ==================== SCENE 6: PROPOSAL ====================
            transitionToScene6() {
                try {
                    this.clearAutoAdvance();
                    this.currentScene = 6;
                    
                    // Hide canvas
                    this.canvas.style.opacity = '0';
                    
                    // Show proposal UI
                    document.getElementById('scene6').classList.remove('hidden');
                    
                    // Reset NO button position
                    const noButton = document.getElementById('noButton');
                    noButton.style.position = 'relative';
                    noButton.style.left = '0';
                    noButton.style.top = '0';
                    
                } catch (error) {
                    console.warn('Transition to scene 6 failed:', error);
                }
            }

            handleYes() {
                try {
                    // Play chime sound
                    this.audio.play('chime');
                    
                    // Create petal rain particles
                    for (let i = 0; i < 100; i++) {
                        setTimeout(() => {
                            const x = Math.random() * window.innerWidth;
                            const y = -10;
                            const colors = ['#fbbf24', '#ec4899', '#a78bfa', '#34d399'];
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            this.particles.push(new Particle(x, y, color, {
                                x: (Math.random() - 0.5) * 2,
                                y: Math.random() * 2 + 1
                            }));
                        }, i * 50);
                    }
                    
                    // Show canvas for petal animation
                    this.canvas.style.opacity = '1';
                    
                    // Update proposal text
                    document.getElementById('proposalText').textContent = 'You were always my favorite galaxy ðŸŒ™ðŸŒ·';
                    
                    // Hide buttons
                    document.querySelector('.proposal-buttons').classList.add('hidden');
                    
                    // Stop sounds after a moment
                    setTimeout(() => {
                        if (this.windSound) this.audio.stop(this.windSound);
                        if (this.heartbeatSound) this.audio.stop(this.heartbeatSound);
                    }, 3000);
                    
                } catch (error) {
                    console.warn('YES handler failed:', error);
                }
            }

            dodgeNoButton() {
                try {
                    const noButton = document.getElementById('noButton');
                    const buttonRect = noButton.getBoundingClientRect();
                    
                    // Move button to random position
                    const maxX = window.innerWidth - buttonRect.width - 40;
                    const maxY = window.innerHeight - buttonRect.height - 40;
                    
                    const randomX = Math.random() * maxX + 20;
                    const randomY = Math.random() * maxY + 20;
                    
                    noButton.style.position = 'absolute';
                    noButton.style.left = randomX + 'px';
                    noButton.style.top = randomY + 'px';
                    
                } catch (error) {
                    console.warn('NO button dodge failed:', error);
                }
            }

            fallbackToScene6() {
                this.currentScene = 6;
                document.getElementById('scene6').classList.remove('hidden');
            }

            // ==================== ANIMATION LOOP ====================
            startAnimationLoop() {
                const animate = (time) => {
                    try {
                        switch (this.currentScene) {
                            case 1:
                                this.drawScene1(this.ctx);
                                break;
                            case 2:
                                this.drawScene2(this.ctx, time);
                                break;
                            case 5:
                                this.drawScene5(this.ctx, time);
                                break;
                            default:
                                // Clear canvas when not in use
                                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                                this.updateParticles(this.ctx);
                        }
                    } catch (error) {
                        console.warn('Animation frame failed:', error);
                    }
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate(0);
            }

            updateParticles(ctx) {
                try {
                    this.particles = this.particles.filter(particle => {
                        particle.update();
                        particle.draw(ctx);
                        return !particle.isDead();
                    });
                } catch (error) {
                    console.warn('Particle update failed:', error);
                }
            }
        }

        // ==================== INITIALIZATION ====================
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                new SceneManager();
            });
        } else {
            new SceneManager();
        }

        // Handle page visibility changes to pause/resume audio
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Pause audio when page is hidden
                if (window.sceneManager && window.sceneManager.audio.audioContext) {
                    window.sceneManager.audio.audioContext.suspend();
                }
            } else {
                // Resume audio when page is visible
                if (window.sceneManager && window.sceneManager.audio.audioContext) {
                    window.sceneManager.audio.audioContext.resume();
                }
            }
        });
    </script>
</body>
</html>
