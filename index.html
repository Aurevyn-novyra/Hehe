<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Will you be my universe?</title>
<style>
  /* ---------- Base reset & layout ---------- */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body,#app{height:100%}
  body{
    background:#000;
    color:#fff;
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }
  #app{position:relative;width:100%;height:100vh;overflow:hidden}

/* canvases stack */
canvas{position:absolute;inset:0;display:block;width:100%;height:100%}

/* subtle fog for cinematic look */
.fog{
position:absolute;inset:0;pointer-events:none;z-index:6;
background:
radial-gradient(ellipse at 20% 20%, rgba(160,80,220,0.09), transparent 20%),
radial-gradient(ellipse at 80% 80%, rgba(120,30,160,0.06), transparent 25%),
linear-gradient(180deg, rgba(8,4,14,0.25), rgba(0,0,0,0.6));
mix-blend-mode:screen;filter:blur(22px) saturate(120%);opacity:.95;
}

/* UI center panel */
.ui{position:relative;z-index:10;width:min(980px,94%);margin:0 auto;text-align:center;
pointer-events:none;top:12vh}

.centerText{
font-size:clamp(18px,3.4vw,30px);
color:#f3ecfb;
text-shadow:0 18px 40px rgba(0,0,0,.8);
opacity:0;transform:translateY(10px);
transition:opacity .85s ease, transform .85s cubic-bezier(.2,.9,.2,1);
}

/* main CTA - touch friendly */
.cta{
margin-top:26px;
pointer-events:auto;
display:inline-block;
padding:14px 36px;border-radius:40px;
font-size:clamp(16px,2.6vw,20px);
color:#fff;background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
border:1px solid rgba(255,255,255,.12);
box-shadow:0 30px 90px rgba(160,60,200,.34), inset 0 -6px 18px rgba(255,255,255,.02);
cursor:pointer;touch-action:manipulation;user-select:none;
transform:translateZ(0);
}
.cta:active{transform:scale(.985)}

/* buttery pulse */
.pulse{animation:pulse 2200ms ease-in-out infinite}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)}}

/* small controls */
.controls{margin-top:18px;pointer-events:auto;display:flex;gap:12px;justify-content:center}
.btn{padding:12px 22px;border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.06);color:#fff;cursor:pointer;min-width:130px;font-size:16px}
.big{min-width:170px;padding:14px 30px;border-radius:26px;font-size:18px}

/* poem box - breathing light behind it */
.breath{position:absolute;inset:0;z-index:4;pointer-events:none;mix-blend-mode:screen;opacity:.35}
.poemBox{margin:0 auto;margin-top:22px;max-width:760px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.03));padding:18px;border-radius:14px;backdrop-filter:blur(6px);box-shadow:0 20px 60px rgba(10,6,30,.5);pointer-events:none}
.poemLine{font-size:clamp(16px,2.4vw,20px);line-height:1.45;min-height:2.2em;color:#f1eef9;white-space:pre-wrap;overflow:hidden}

/* proposal overlay */
.proposal{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20;pointer-events:none;opacity:0;transition:opacity .6s ease}
.card{pointer-events:auto;background:linear-gradient(180deg,rgba(10,6,18,0.85),rgba(10,6,18,0.6));padding:28px;border-radius:20px;border:1px solid rgba(255,255,255,.04);box-shadow:0 40px 120px rgba(10,6,20,.75);text-align:center}
.proposalText{font-size:clamp(18px,3.6vw,28px);margin-bottom:14px;color:#fffbff}

/* NO button dodge styling */
.dodge{transform:translateX(36px) translateY(-8px) scale(1.03);transition:transform .18s cubic-bezier(.2,.9,.3,1)}

/* responsive tweaks */
@media (max-width:520px){
.cta{padding:12px 20px;border-radius:22px}
.btn{min-width:110px;padding:12px 16px;font-size:15px}
.poemLine{font-size:15px}
} </style>

</head>
<body>
<div id="app" aria-live="polite">
  <!-- Main stacked canvases (high-DPR handled in JS) -->
  <canvas id="main"></canvas>      <!-- starfield + tulip garden + particles -->
  <canvas id="bouquet"></canvas>   <!-- flying bouquet + ribbon -->
  <canvas id="petals"></canvas>    <!-- petal rain -->
  <div class="fog" aria-hidden="true"></div>

  <!-- UI -->

  <div class="ui" id="ui">
    <div class="centerText" id="introText">This isnâ€™t a normal websiteâ€¦</div>

```
<div id="introControls" style="margin-top:18px">
  <button id="tap" class="cta pulse" aria-label="Tap me to continue">Tap Me</button>
  <div style="height:8px"></div>
  <div id="fallback" style="display:none">
    <button id="fallbackBtn" class="btn">Continue</button>
  </div>
</div>

<div id="tulipControls" style="display:none" class="controls">
  <button id="toPoem" class="btn big">Continue</button>
</div>

<div id="poemScene" style="display:none">
  <div class="breath" aria-hidden="true"></div>
  <div class="poemBox" id="poemBox" aria-live="polite">
    <div id="line1" class="poemLine"></div>
    <div id="line2" class="poemLine"></div>
  </div>
  <div class="controls" style="margin-top:12px">
    <button id="nextLine" class="btn big">Next</button>
  </div>
</div>

<div id="build" style="display:none" class="controls">
  <button id="oneLast" class="btn big">One Last Thingâ€¦</button>
</div>
```

  </div>

  <div class="proposal" id="proposal" role="dialog" aria-modal="true">
    <div class="card" id="proposalCard" style="display:none">
      <div class="proposalText" id="proposalText">Will you be my universe? ðŸ’«</div>
      <div style="display:flex;gap:12px;justify-content:center">
        <button id="yes" class="btn big" style="background:linear-gradient(180deg,#ffecf8,#ffdff2);color:#3b0b2e">YES</button>
        <button id="no" class="btn big" id="noBtn" style="background:linear-gradient(180deg,#1a1a1a,#0e0c12);color:#fff">NO</button>
      </div>
      <div style="margin-top:10px;color:rgba(255,255,255,.6);font-size:13px">(Tip: be sincere)</div>
    </div>
  </div>
</div>

<script>
/*
  Ultra-cinematic, buttery-smooth single-file romantic proposal
  - Heavy comments for clarity
  - All visuals: Canvas; All audio: WebAudio API (synthetic)
  - Scenes: intro -> tulips -> poem -> build -> bouquet -> proposal
  - Mobile/touch safe, auto-advance fallback, try/catch safety
  - Designed for scenario B: cinematic + higher GPU usage
*/

(function(){
  'use strict';

  /* ---------------- App state ---------------- */
  const App = {
    // canvas elements and contexts assigned in initCanvas()
    main: null, ctx: null,
    bouquet: null, bctx: null,
    petals: null, pctx: null,
    width: 0, height: 0,
    DPR: Math.min(window.devicePixelRatio || 1, 2),
    scene: 'intro', // intro, tulips, poem, build, bouquet, proposal
    raf: null,
    lastInteraction: Date.now(),
    poemLines: [],
    poemIndex: 0,
    audioCtx: null,
    audioNodes: {},
    // systems
    starfield: null,
    tulipGarden: null,
    particles: null,
    bouquetSys: null,
    petalSys: null
  };

  /* ---------------- DOM cached elements ---------------- */
  const DOM = {
    introText: document.getElementById('introText'),
    tap: document.getElementById('tap'),
    fallbackWrap: document.getElementById('fallback'),
    fallbackBtn: document.getElementById('fallbackBtn'),
    tulipControls: document.getElementById('tulipControls'),
    toPoem: document.getElementById('toPoem'),
    poemScene: document.getElementById('poemScene'),
    line1: document.getElementById('line1'),
    line2: document.getElementById('line2'),
    nextLine: document.getElementById('nextLine'),
    buildWrap: document.getElementById('build'),
    oneLast: document.getElementById('oneLast'),
    proposal: document.getElementById('proposal'),
    proposalCard: document.getElementById('proposalCard'),
    proposalText: document.getElementById('proposalText'),
    yes: document.getElementById('yes'),
    no: document.getElementById('no')
  };

  /* ---------------- Utility functions ---------------- */
  const O = {
    clamp(v,a,b){ return Math.max(a,Math.min(b,v)); },
    easeOutExpo(t){ return t===1?1:1 - Math.pow(2, -10 * t); },
    easeInOutCubic(t){ return t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2; },
    rand(a,b){ return a + Math.random()*(b-a); },
    now(){ return performance.now(); }
  };

  /* ---------------- Initialize canvases & sizes ---------------- */
  function initCanvas(){
    App.main = document.getElementById('main');
    App.ctx = App.main.getContext('2d',{alpha:true});
    App.bouquet = document.getElementById('bouquet');
    App.bctx = App.bouquet.getContext('2d',{alpha:true});
    App.petals = document.getElementById('petals');
    App.pctx = App.petals.getContext('2d',{alpha:true});

    function resize(){
      try{
        App.width = Math.max(document.documentElement.clientWidth || 300, 300);
        App.height = Math.max(document.documentElement.clientHeight || 300, 300);
        const DPR = App.DPR;
        [App.main, App.bouquet, App.petals].forEach(c=>{
          c.width = Math.floor(App.width * DPR);
          c.height = Math.floor(App.height * DPR);
          c.style.width = App.width + "px";
          c.style.height = App.height + "px";
          const ctx = c.getContext('2d');
          ctx.setTransform(DPR,0,0,DPR,0,0);
          // high-quality rendering hints
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
        });
      }catch(err){
        console.warn('resize error', err);
      }
    }
    window.addEventListener('resize', resize);
    resize();
  }

  /* ---------------- WebAudio: ambient wind, heartbeat, whoosh, chime ---------------- */
  function initAudio(){
    try{
      if(App.audioCtx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      App.audioCtx = new Ctx();
      const master = App.audioCtx.createGain();
      master.gain.value = 0.9;
      master.connect(App.audioCtx.destination);
      App.audioNodes.master = master;

      setupAmbientWind();
      setupHeartbeat();
      // whoosh and chime are one-shots triggered later
    }catch(e){
      console.warn('initAudio failed', e);
    }
  }

  function setupAmbientWind(){
    try{
      const ctx = App.audioCtx;
      const len = ctx.sampleRate * 3.0; // 3s buffer
      const buffer = ctx.createBuffer(1, len, ctx.sampleRate);
      const ch = buffer.getChannelData(0);
      // generate smooth noise (pinkish)
      for(let i=0;i<len;i++){
        const w = (Math.random()*2-1);
        ch[i] = (w + (i?ch[i-1]:0)*0.92) * 0.5;
      }
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 900 + Math.random()*1000;
      const gain = ctx.createGain(); gain.gain.value = 0.08;
      src.connect(filter); filter.connect(gain); gain.connect(App.audioNodes.master);
      src.start();
      App.audioNodes.wind = {src,filter,gain};
    }catch(e){ console.warn('ambient wind error', e); }
  }

  function setupHeartbeat(){
    try{
      const ctx = App.audioCtx;
      const osc = ctx.createOscillator();
      osc.type = 'sine'; osc.frequency.value = 36;
      const g = ctx.createGain(); g.gain.value = 0.01;
      osc.connect(g); g.connect(App.audioNodes.master); osc.start();
      App.audioNodes.heartbeat = {osc,g};
      // gentle pulsing using scheduled ramps
      const pulse = ()=>{
        const now = ctx.currentTime;
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0.01, now);
        g.gain.exponentialRampToValueAtTime(0.6, now + 0.18);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.9);
      };
      pulse();
      App.audioNodes.heartbeat.interval = setInterval(pulse, 920);
    }catch(e){ console.warn('heartbeat error', e); }
  }

  function playWhoosh(){
    try{
      const ctx = App.audioCtx;
      const dur = 0.42;
      const len = Math.floor(ctx.sampleRate * dur);
      const buffer = ctx.createBuffer(1,len,ctx.sampleRate);
      const d = buffer.getChannelData(0);
      for(let i=0;i<len;i++){
        d[i] = (Math.random()*2-1) * Math.exp(-i/(len*0.85));
      }
      const src = ctx.createBufferSource(); src.buffer = buffer;
      const flt = ctx.createBiquadFilter(); flt.type='bandpass'; flt.frequency.value=900;
      const g = ctx.createGain(); g.gain.value = 0.9;
      src.connect(flt); flt.connect(g); g.connect(App.audioNodes.master);
      src.start();
      flt.frequency.setValueAtTime(4000, ctx.currentTime);
      flt.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + dur);
    }catch(e){ console.warn('whoosh error', e); }
  }

  function playChime(){
    try{
      const ctx = App.audioCtx;
      const now = ctx.currentTime;
      const base = 440;
      const freqs = [base, base*1.5, base*2.02];
      freqs.forEach((f,i)=>{
        const o = ctx.createOscillator(); o.type='sine'; o.frequency.value = f*(1+(Math.random()-0.5)*0.01);
        const g = ctx.createGain(); g.gain.value = 0;
        const flt = ctx.createBiquadFilter(); flt.type='lowpass'; flt.frequency.value = 8000 - i*600;
        o.connect(flt); flt.connect(g); g.connect(App.audioNodes.master);
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.18/(i+1), now + 0.02 + i*0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 3 + i*0.3);
        o.start(now + i*0.02); o.stop(now + 4 + i*0.3);
      });
      // sparkle overtone
      const o2 = ctx.createOscillator(); o2.type='triangle'; o2.frequency.value = base*0.5;
      const g2 = ctx.createGain(); g2.gain.value = 0;
      o2.connect(g2); g2.connect(App.audioNodes.master);
      g2.gain.setValueAtTime(0, now); g2.gain.linearRampToValueAtTime(0.06, now+0.04);
      g2.gain.exponentialRampToValueAtTime(0.0001, now+3.2);
      o2.start(); o2.stop(now+3.8);
    }catch(e){ console.warn('chime error', e); }
  }

  /* ---------------- Starfield (layered parallax with subtle movement) ---------------- */
  function createStarfield(){
    const stars = [];
    const layers = [
      {count: 80, speed: 0.02, size: [0.4,1.2], alpha:0.6},
      {count: 60, speed: 0.05, size: [0.8,1.8], alpha:0.8},
      {count: 40, speed: 0.12, size: [1.2,2.6], alpha:1.0}
    ];
    layers.forEach((layer, idx)=>{
      for(let i=0;i<layer.count;i++){
        stars.push({
          x: Math.random()*App.width,
          y: Math.random()*App.height,
          r: O.rand(layer.size[0], layer.size[1]),
          speed: layer.speed * (0.6 + Math.random()*0.9),
          alpha: layer.alpha * (0.7 + Math.random()*0.5),
          hue: 240 + Math.random()*100,
          layer: idx,
          phase: Math.random()*Math.PI*2
        });
      }
    });
    return {
      stars,
      t:0,
      draw(now){
        try{
          const ctx = App.ctx;
          this.t = (now/1000) || 0;
          // backdrop gradient
          const g = ctx.createLinearGradient(0,0,0,App.height);
          g.addColorStop(0,'#040007'); g.addColorStop(1,'#020015');
          ctx.fillStyle = g; ctx.fillRect(0,0,App.width,App.height);

          // subtle nebula bloom
          const ng = ctx.createRadialGradient(App.width*0.18, App.height*0.13, 0, App.width*0.18, App.height*0.13, App.width*0.9);
          ng.addColorStop(0,'rgba(160,80,220,0.085)'); ng.addColorStop(0.6,'rgba(80,30,120,0.03)'); ng.addColorStop(1,'rgba(0,0,0,0)');
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = ng; ctx.fillRect(0,0,App.width,App.height);
          ctx.globalCompositeOperation = 'source-over';

          // draw stars with twinkle
          for(let s of this.stars){
            const tw = 0.5 + Math.sin(this.t*1.2*s.speed + s.phase)*0.5;
            const size = s.r * (0.8 + tw*0.6);
            ctx.beginPath();
            ctx.globalAlpha = O.clamp(s.alpha * (0.6 + tw*0.5), 0.2, 1);
            ctx.fillStyle = `hsl(${s.hue} 100% ${O.clamp(55 + tw*24,50,92)}%)`;
            // micro parallax movement
            const ox = Math.sin(this.t*0.3*s.speed + s.phase)*6*(s.layer+0.2);
            const oy = Math.cos(this.t*0.17*s.speed + s.phase)*4*(s.layer+0.2);
            ctx.arc(s.x + ox, s.y + oy, size, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }catch(e){ console.warn('Starfield.draw error', e); }
      }
    };
  }

  /* ---------------- Tulip garden: many tulips, bezier stems, layered petals, sway ---------------- */
  function createTulipGarden(){
    const tulips = [];
    function makePetals(hue, size){
      return [
        {r: size*0.72, layer:-1, stops: [{t:0,'c':'rgba(8,6,14,0.0)'},{t:1,'c':'rgba(6,2,14,0.38)'}]},
        {r: size*0.62, layer:0, stops: [{t:0,'c':'rgba(255,245,250,0.95)'},{t:1,'c':`hsl(${hue} 80% 46%)`} ]},
        {r: size*0.42, layer:1, stops: [{t:0,'c':'rgba(255,255,255,0.92)'},{t:1,'c':`hsl(${hue} 78% 62%)`}]}
      ];
    }
    function generate(count){
      tulips.length = 0;
      for(let i=0;i<count;i++){
        const depth = Math.random();
        const x = Math.random() * App.width;
        // place near bottom range
        const y = App.height * (0.48 + depth*0.46 + Math.random()*0.03);
        const size = 18 + depth*46 + Math.random()*18;
        const hue = 320 + Math.random()*70;
        tulips.push({
          x,y,depth,size,hue,
          swayPhase: Math.random()*Math.PI*2,
          swaySpeed: 0.0006 + Math.random()*0.0016,
          stemCurviness: 0.08 + Math.random()*0.24,
          petals: makePetals(hue,size),
          isFront: depth > 0.65
        });
      }
      tulips.sort((a,b)=>a.depth-b.depth);
      return tulips;
    }

    // efficient draw: draw ground gradient then loop tulips
    function draw(now){
      try{
        const ctx = App.ctx;
        // ground gradient from horizon down
        const g = ctx.createLinearGradient(0, App.height*0.45, 0, App.height);
        g.addColorStop(0,'rgba(6,3,8,0.0)'); g.addColorStop(1,'rgba(8,4,10,0.7)');
        ctx.fillStyle = g; ctx.fillRect(0, App.height*0.45, App.width, App.height*0.55);

        const t = now || Date.now();
        for(const tulip of tulips){
          drawTulip(ctx, t, tulip);
        }
      }catch(e){
        console.warn('TulipGarden.draw error', e);
      }
    }

    function drawTulip(ctx, t, tulip){
      try{
        const sway = Math.sin(t * tulip.swaySpeed + tulip.swayPhase) * (6 + (1 - tulip.depth)*4);
        const stemTopX = tulip.x + sway;
        const stemTopY = tulip.y;
        const baseX = tulip.x + (Math.random()-0.5)*18;
        const baseY = App.height + 36;

        // stem
        ctx.beginPath();
        ctx.lineWidth = O.clamp(1.6 * (1 + tulip.depth*1.8), 1, 5.5);
        ctx.strokeStyle = `rgba(30,110,60,${0.7 - tulip.depth*0.45})`;
        const cp1x = baseX + (stemTopX - baseX) * tulip.stemCurviness + (Math.random()-0.5)*24;
        const cp1y = baseY - (App.height - stemTopY)*0.45;
        const cp2x = baseX + (stemTopX - baseX) * (0.6 + tulip.stemCurviness) + (Math.random()-0.5)*22;
        const cp2y = baseY - (App.height - stemTopY)*0.78;
        ctx.moveTo(baseX, baseY);
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, stemTopX, stemTopY);
        ctx.stroke();

        // soft drop shadow under bloom
        const shadowR = 6 + (1 - tulip.depth)*20;
        const sh = ctx.createRadialGradient(stemTopX+6, stemTopY+8, 1, stemTopX+6, stemTopY+8, shadowR*1.6);
        sh.addColorStop(0,'rgba(0,0,0,0.28)'); sh.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle = sh;
        ctx.beginPath(); ctx.ellipse(stemTopX+6, stemTopY+8, shadowR, shadowR*0.45, 0, 0, Math.PI*2); ctx.fill();

        // layered petals using radial gradients for depth & sheen
        const cx = stemTopX, cy = stemTopY;
        for(const p of tulip.petals){
          const grad = ctx.createRadialGradient(cx, cy - p.r*0.18, p.r*0.06, cx, cy + p.r*0.6, p.r*1.4);
          for(const s of p.stops) grad.addColorStop(s.t, s.c);
          ctx.fillStyle = grad;
          ctx.beginPath();
          const petalW = p.r * (1.18 - tulip.depth*0.36);
          const petalH = p.r * (0.92 - tulip.depth*0.2);
          const rot = Math.sin(tulip.swayPhase + p.layer*0.7) * 0.45;
          ctx.save();
          ctx.translate(cx, cy - (p.layer*2));
          ctx.rotate(rot);
          ctx.ellipse(0, 0, petalW, petalH, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        // center soft highlight
        const glow = ctx.createRadialGradient(cx,cy,0,cx,cy, 28);
        glow.addColorStop(0,'rgba(255,255,255,0.16)'); glow.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(cx,cy,18*(1 - tulip.depth*0.28),0,Math.PI*2); ctx.fill();

      }catch(e){ console.warn('drawTulip error', e); }
    }

    function detachFront(targetX, targetY){
      // pick some front tulips to fly into bouquet
      const front = tulips.filter(t=>t.isFront);
      const pick = [];
      for(let i=0;i<Math.min(10, front.length); i++){
        const t = front[Math.floor(front.length * (i/front.length))] || front[i];
        pick.push({
          x: t.x, y: t.y,
          vx: (targetX - t.x)/700 + O.rand(-0.3,0.3),
          vy: (targetY - t.y)/900 + O.rand(-0.3,0),
          r: t.size, hue: t.hue
        });
      }
      return pick;
    }

    return {generate, draw, detachFront};
  }

  /* ---------------- Particle system for button disintegration (GPU-friendly) ---------------- */
  function createParticles(){
    const parts = [];
    function spawn(x,y,color,count=80){
      for(let i=0;i<count;i++){
        parts.push({
          x,y,
          vx: O.rand(-3,3),
          vy: O.rand(-6,-1.8),
          rot: Math.random()*Math.PI*2,
          vr: O.rand(-0.12,0.12),
          life: O.rand(0.8,1.6),
          age: 0,
          size: O.rand(2,8),
          color: color || `hsl(${320 + Math.random()*50} 85% ${O.rand(40,70)}%)`
        });
      }
    }
    function updateAndDraw(ctx, dt){
      try{
        if(parts.length===0) return;
        for(let i=parts.length-1;i>=0;i--){
          const p = parts[i];
          p.age += dt;
          if(p.age >= p.life){ parts.splice(i,1); continue; }
          p.vy += 9.8 * dt;
          p.x += p.vx * (60*dt);
          p.y += p.vy * (60*dt);
          p.rot += p.vr;
          const a = O.clamp(1 - p.age / p.life, 0, 1);
          ctx.save();
          ctx.globalAlpha = a;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.ellipse(0,0,p.size*0.6,p.size*0.9,0,0,Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }catch(e){ console.warn('Particles.updateAndDraw', e); }
    }
    return {spawn, updateAndDraw};
  }

  /* ---------------- Bouquet flight system (flowers + ribbon) ---------------- */
  function createBouquet(){
    let flowers = [];
    let bow = null;
    let active = false;
    function start(flowerDefs, targetX, targetY){
      flowers = flowerDefs.map((d,i)=>({
        x: d.x, y: d.y,
        vx: d.vx, vy: d.vy,
        r: d.r, hue: d.hue,
        life: 2.6 + Math.random()*1.2,
        age: 0,
        offset: i
      }));
      bow = {x: targetX, y: targetY, t: 0};
      active = true;
    }
    function updateAndDraw(ctx, dt){
      try{
        if(!active) return;
        ctx.save();
        for(let i=flowers.length-1;i>=0;i--){
          const f = flowers[i];
          f.age += dt;
          if(f.age > f.life){ flowers.splice(i,1); continue; }
          // gentle acceleration towards center
          f.vx += ( (bow.x - f.x) * 0.003 ) * dt * 120;
          f.vy += ( (bow.y - f.y) * 0.003 ) * dt * 120;
          f.x += f.vx * (60*dt);
          f.y += f.vy * (60*dt);
          // draw small floral head
          ctx.save();
          ctx.translate(f.x, f.y);
          ctx.beginPath();
          ctx.fillStyle = `hsl(${f.hue} 80% 60%)`;
          ctx.arc(0,0, Math.max(3, f.r*0.16), 0, Math.PI*2); ctx.fill();
          // tiny petals
          for(let p=0;p<5;p++){
            ctx.rotate((Math.PI*2)/5);
            ctx.beginPath();
            ctx.ellipse(6,0, f.r*0.16, f.r*0.32, 0,0,Math.PI*2);
            ctx.fillStyle = `rgba(255,245,248,${0.9 - p*0.12})`;
            ctx.fill();
          }
          ctx.restore();
        }
        // ripple ribbon & bow at target
        if(bow){
          bow.t += dt * 1.6;
          const tx = bow.x, ty = bow.y;
          for(let i=0;i<4;i++){
            ctx.beginPath();
            const r = 18 + i*8 + Math.sin(bow.t*1.6 + i)*6;
            ctx.ellipse(tx, ty + 6, r, r*0.28, Math.sin(bow.t + i)*0.4, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255,220,240,${0.16 - i*0.02})`;
            ctx.lineWidth = 2.2; ctx.stroke();
          }
          // bow knot
          ctx.beginPath(); ctx.fillStyle='rgba(255,200,230,0.98)';
          ctx.ellipse(tx-6, ty-2, 10,6, -0.6,0,Math.PI*2);
          ctx.ellipse(tx+6, ty-2, 10,6, 0.6,0,Math.PI*2);
          ctx.fill();
          ctx.beginPath(); ctx.fillStyle='rgba(220,90,140,1)'; ctx.arc(tx, ty+6, 4,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }catch(e){ console.warn('Bouquet.updateAndDraw', e); }
    }
    function isDone(){ return flowers.length === 0; }
    function activeState(){ return active; }
    return {start, updateAndDraw, isDone, activeState};
  }

  /* ---------------- Petal rain system ---------------- */
  function createPetals(){
    let petals = [];
    function start(count=80){
      petals = [];
      for(let i=0;i<count;i++){
        petals.push({
          x: Math.random()*App.width,
          y: -Math.random()*App.height,
          vx: O.rand(-0.6,0.6),
          vy: O.rand(0.6,2.6),
          rot: Math.random()*Math.PI*2,
          vr: O.rand(-0.05,0.05),
          size: O.rand(8,20),
          hue: 320 + Math.random()*60
        });
      }
    }
    function updateAndDraw(ctx, dt){
      try{
        for(let i=petals.length-1;i>=0;i--){
          const p = petals[i];
          p.x += p.vx * (80*dt);
          p.y += p.vy * (80*dt);
          p.rot += p.vr;
          if(p.y > App.height + 40){ petals.splice(i,1); continue; }
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          const g = ctx.createLinearGradient(-p.size, -p.size, p.size, p.size);
          g.addColorStop(0, 'rgba(255,255,255,0.95)');
          g.addColorStop(1, `hsl(${p.hue} 85% 60%)`);
          ctx.fillStyle = g; ctx.globalAlpha = 0.94;
          ctx.beginPath();
          ctx.ellipse(0,0,p.size*0.6,p.size,0,0,Math.PI*2); ctx.fill();
          ctx.restore();
        }
      }catch(e){ console.warn('Petal.updateAndDraw', e); }
    }
    return {start, updateAndDraw};
  }

  /* ---------------- Poem system (typewriter two-lines) ---------------- */
  function initPoemLines(){
    const poem = `Sometimes I think I fell for you
before I even learned how falling works.
My words trip over themselves..
And as I said earlier.. you're like a Luminous Singularity
which's parallel yet coincidently intersecting...
Like constellations shuffled in a hurry...
Orion losing its belt..
Cassiopeia sitting upside down..
and whole sky is asking "Why is she the only one shining this bright?"
And I swear ... 
every time i try to explain what you mean to me.. I fumble..I'm scared...
and my heart chooses Your tulips instead of sentences 
petals arranged in a wrong order.. yet beautiful..
Colors mixing where they shouldn't yet somehow looking eternal..
and it's strange how You make the universe feel like a misprinted bouquet..
Galaxies scribbled over with your name..
planets orbiting a little too close..
a pull like the Black hole..
Like they too forgot their distance.
And me? I'm jst a boy holding a bouquet thinking maybe if I say it wrong enough times
you Might hear the truth hidden between the mistakes
That in every star's cold shimmer and every tulip's quite softness
i keep finding you 
not perfectly..
not clearly 
but completely...`;
    App.poemLines = poem.split('\n');
    App.poemIndex = 0;
  }
  let typing = false;
  function showNextPoem(){
    if(typing) return;
    typing = true;
    const i = App.poemIndex;
    const l1 = App.poemLines[i] || '';
    const l2 = App.poemLines[i+1] || '';
    App.poemIndex += 2;
    DOM.line1.textContent = ''; DOM.line2.textContent = '';
    DOM.poemScene.style.display = 'block';
    DOM.poemBox.scrollIntoView({behavior:'smooth',block:'center'});

    function type(el,text,speed){
      return new Promise(res=>{
        let idx=0;
        const s = Math.max(7, Math.min(28, Math.floor(speed)));
        const tId = setInterval(()=>{
          try{
            idx++;
            el.textContent = text.slice(0,idx);
            if(idx>=text.length){ clearInterval(tId); res(); }
          }catch(e){ clearInterval(tId); res(); }
        }, s);
      });
    }

    (async ()=>{
      try{
        await type(DOM.line1, l1, 14 + l1.length/8);
        await new Promise(r=>setTimeout(r,200));
        await type(DOM.line2, l2, 12 + l2.length/9);
        typing = false;
        // auto transition when poem ends
        if(App.poemIndex >= App.poemLines.length){
          setTimeout(()=>transitionToBuild(), 1000);
        }
      }catch(e){ typing=false; console.warn('type error', e); }
    })();
  }

  /* ---------------- Scene transitions & controls wiring ---------------- */
  function goToTulips(){
    try{
      App.scene = 'tulips';
      DOM.introText.style.opacity = 0;
      DOM.tap.style.display = 'none';
      DOM.fallbackWrap.style.display = 'none';
      DOM.tulipControls.style.display = 'flex';
      // generate garden with density tuned to width
      const count = Math.floor(App.width/22) + 14;
      App.tulipGarden = createTulipGarden(); App.tulipGarden.generate = App.tulipGarden.generate || App.tulipGarden.generate;
      // regenerate using internal function
      App.tulipGarden = (function(){ // create fresh garden object to maintain closure
        const g = createTulipGarden();
        g.generate(count);
        return g;
      })();
      // particles and systems
      App.particles = createParticles();
      App.bouquetSys = createBouquet();
      App.petalSys = createPetals();
      // audio whoosh + subtle camera scale (CSS)
      safe(()=>{ initAudio(); playWhoosh(); });
      // small cinematic camera nudge (CSS on body)
      document.documentElement.animate([{transform:'scale(1)'},{transform:'scale(1.02)'}],{duration:420,iterations:2,direction:'alternate',easing:'ease-out'});
    }catch(e){ console.warn('goToTulips', e); }
  }

  function transitionToPoem(){
    try{
      App.scene = 'poem';
      DOM.tulipControls.style.display = 'none';
      initPoemLines();
      showNextPoem();
      safe(()=>playWhoosh());
    }catch(e){ console.warn('transitionToPoem', e); }
  }

  function transitionToBuild(){
    try{
      App.scene = 'build';
      DOM.poemScene.style.display = 'none';
      DOM.buildWrap.style.display = 'flex';
      safe(()=>playWhoosh());
    }catch(e){ console.warn('transitionToBuild', e); }
  }

  function startBouquet(){
    try{
      App.scene = 'bouquet';
      DOM.buildWrap.style.display = 'none';
      // detach tulips into bouquet and start flight to screen center
      const tx = App.width/2, ty = App.height*0.38;
      const defs = App.tulipGarden.detachFront(tx, ty);
      App.bouquetSys.start(defs, tx, ty);
      safe(()=>playWhoosh());
      // poll for completion then show proposal
      (function check(){
        if(App.bouquetSys.isDone()) setTimeout(()=>showProposal(), 650);
        else setTimeout(check, 380);
      })();
    }catch(e){ console.warn('startBouquet', e); }
  }

  function showProposal(){
    try{
      App.scene = 'proposal';
      DOM.proposal.style.pointerEvents = 'auto';
      DOM.proposal.style.display = 'flex';
      setTimeout(()=>{ DOM.proposal.style.opacity = 1; DOM.proposalCard.style.display = 'block'; }, 80);
      // heart quicken
      if(App.audioNodes.heartbeat && App.audioCtx){
        const g = App.audioNodes.heartbeat.g; const ctx = App.audioCtx; const now = ctx.currentTime;
        g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0.02, now); g.gain.linearRampToValueAtTime(0.95, now+0.5);
        g.gain.exponentialRampToValueAtTime(0.02, now+3.2);
      }
    }catch(e){ console.warn('showProposal', e); }
  }

  /* ---------------- Safe play helper to resume audio on user gesture ---------------- */
  function safe(fn){ try{ fn && fn(); }catch(e){ console.warn('safe', e); } }
  function safePlayAudio(fn){
    try{
      if(App.audioCtx && App.audioCtx.state === 'suspended'){ App.audioCtx.resume().catch(()=>{}); }
      fn && fn();
    }catch(e){ console.warn('safePlayAudio', e); }
  }

  /* ---------------- Auto-advance safety (10s per scene) ---------------- */
  function setupAutoAdvance(){
    (function tick(){
      try{
        const since = Date.now() - App.lastInteraction;
        if(since > 10000){
          if(App.scene === 'intro'){ DOM.tap.click(); }
          else if(App.scene === 'tulips'){ DOM.toPoem.click(); }
          else if(App.scene === 'poem'){ DOM.nextLine.click(); }
          else if(App.scene === 'build'){ DOM.oneLast.click(); }
          App.lastInteraction = Date.now();
        }
      }catch(e){ console.warn('autoAdvance', e); }
      setTimeout(tick, 3500);
    })();
  }

  /* ---------------- Main render loop (single RAF controlling all layers) ---------------- */
  let last = performance.now();
  function loop(now){
    try{
      const dt = Math.min(0.06, (now - last)/1000);
      last = now;

      // draw starfield always (background)
      App.starfield.draw(now);

      // draw tulips if ready
      if(App.scene !== 'intro' && App.tulipGarden) App.tulipGarden.draw(now);

      // particles on main canvas
      if(App.particles) App.particles.updateAndDraw(App.ctx, dt);

      // bouquet on bouquet canvas
      App.bctx.clearRect(0,0,App.width,App.height);
      if(App.bouquetSys) App.bouquetSys.updateAndDraw(App.bctx, dt);

      // petals on petals canvas
      App.pctx.clearRect(0,0,App.width,App.height);
      if(App.petalSys) App.petalSys.updateAndDraw(App.pctx, dt);

    }catch(e){
      console.warn('loop error', e);
    } finally {
      App.raf = requestAnimationFrame(loop);
    }
  }

  /* ---------------- Event wiring ---------------- */
  function bind(){
    // mark interaction
    function touch(){
      App.lastInteraction = Date.now();
      try{ initAudio(); }catch(e){}
    }
    ['click','touchstart','keydown','mousemove','scroll'].forEach(ev=>window.addEventListener(ev, ()=>App.lastInteraction = Date.now(), {passive:true}));

    // Tap: disintegrate CTA then go to tulips
    DOM.tap.addEventListener('click', (ev)=>{
      try{
        touch();
        const rect = DOM.tap.getBoundingClientRect();
        const x = rect.left + rect.width/2;
        const y = rect.top + rect.height/2;
        // spawn particles at button location
        App.particles.spawn(x,y,null,110);
        // cinematic camera nudge + whoosh
        document.documentElement.animate([{transform:'scale(1)'},{transform:'scale(1.035)'}], {duration:480, iterations:2, direction:'alternate', easing:'ease-out'});
        safePlayAudio(()=>{ initAudio(); playWhoosh(); });
        setTimeout(goToTulips, 520);
      }catch(e){ console.warn('tap click', e); }
    }, {passive:true});

    // fallback
    DOM.fallbackBtn.addEventListener('click', ()=>{ touch(); goToTulips(); }, {passive:true});

    // to poem
    DOM.toPoem.addEventListener('click', ()=>{ touch(); transitionToPoem(); }, {passive:true});

    // poem next line
    DOM.nextLine.addEventListener('click', ()=>{ touch(); showNextPoem(); }, {passive:true});

    // one last -> bouquet
    DOM.oneLast.addEventListener('click', ()=>{ touch(); startBouquet(); }, {passive:true});

    // YES
    DOM.yes.addEventListener('click', ()=>{
      try{
        touch();
        safePlayAudio(()=>{ initAudio(); playChime(); });
        // petal rain
        App.petalSys.start(140);
        // final text
        DOM.proposalText.textContent = "You were always my favorite galaxy ðŸŒ™ðŸŒ·";
        // mild whoosh
        safePlayAudio(()=>playWhoosh());
        // disable buttons
        DOM.yes.disabled = true; DOM.no.disabled = true;
      }catch(e){ console.warn('yes click', e); }
    }, {passive:true});

    // NO dodge - 2 playful dodges then accept on third attempt for accessibility
    let dodgeCount = 0;
    function dodgeOnce(){
      if(dodgeCount < 2){
        dodgeCount++;
        DOM.no.classList.add('dodge');
        setTimeout(()=>DOM.no.classList.remove('dodge'), 420);
      } else {
        // accept gracefully (accessibility)
        DOM.yes.click();
      }
    }
    DOM.no.addEventListener('mouseenter', dodgeOnce);
    DOM.no.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); dodgeOnce(); }, {passive:false});
  }

  /* ---------------- Initialization entry ---------------- */
  function init(){
    try{
      initCanvas();
      App.starfield = createStarfield();
      App.starfield.init = App.starfield.init || function(){};
      // initialize star positions using internal function
      if(!App.starfield.stars || App.starfield.stars.length===0) App.starfield = createStarfield();
      // systems placeholders to avoid checks
      App.tulipGarden = null; App.particles = createParticles(); App.bouquetSys = createBouquet(); App.petalSys = createPetals();
      // reveal intro text
      setTimeout(()=>{ DOM.introText.style.opacity = 1; DOM.introText.style.transform='translateY(0)'; }, 280);
      // show fallback after 7s if no interaction
      setTimeout(()=>{ if(App.scene==='intro') DOM.fallbackWrap.style.display = 'block'; }, 7000);
      // bind UI
      bind();
      // start RAF loop
      last = performance.now();
      App.raf = requestAnimationFrame(loop);
      // auto-advance safety
      setupAutoAdvance();
      // attempt to init audio on first user gesture for autoplay permissions
      window.addEventListener('click', ()=>{ try{ initAudio(); }catch(e){} }, {once:true});
      window.addEventListener('touchstart', ()=>{ try{ initAudio(); }catch(e){} }, {once:true});
    }catch(e){ console.error('init error', e); }
  }

  /* ---------------- Start app ---------------- */
  init();

  /* Expose debug (commented out to avoid global pollution)
  window._APP = App;
  */

})(); 
</script>

</body>
</html>
