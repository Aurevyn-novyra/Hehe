<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Will you be my universe?</title>
<style>
  /* Basic reset */
  * { box-sizing: border-box; margin:0; padding:0; }
  html,body { height:100%; }
  body {
    background: black;
    color: #efeef8;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    overflow: hidden;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

/* full container */
#app {
position:relative;
width:100%;
height:100vh;
overflow:hidden;
display:flex;
align-items:center;
justify-content:center;
}

/* canvas fills entire area */
canvas {
position:absolute;
inset:0;
width:100%;
height:100%;
display:block;
}

/* subtle overlay fog */
.fog {
position:absolute;
inset:0;
pointer-events:none;
background: radial-gradient(ellipse at 30% 20%, rgba(120,85,200,0.10), transparent 10%),
radial-gradient(ellipse at 80% 80%, rgba(100,50,160,0.08), transparent 15%),
linear-gradient(180deg, rgba(30,10,40,0.25), rgba(0,0,0,0.35));
mix-blend-mode: screen;
opacity:0.9;
filter: blur(14px) saturate(120%);
transform: scale(1.05);
}

/* center UI panel for text/buttons */
.ui {
position:relative;
z-index:10;
text-align:center;
width:min(920px,94%);
pointer-events:none; /* enable only buttons individually */
}

.centerText {
font-size:clamp(18px,3.2vw,28px);
letter-spacing:0.6px;
color: #efeef8;
text-shadow: 0 6px 24px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.02);
opacity:0;
transform:translateY(8px);
}

.mysteryButton {
margin-top:28px;
display:inline-block;
pointer-events:auto;
-webkit-tap-highlight-color: transparent;
background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
border: 1px solid rgba(255,255,255,0.09);
padding: clamp(12px,2.2vw,18px) clamp(20px,6vw,34px);
border-radius: 24px;
font-size: clamp(16px,2.8vw,20px);
cursor:pointer;
color: #fff;
box-shadow: 0 12px 40px rgba(80,40,110,0.35), inset 0 -4px 12px rgba(255,255,255,0.02);
transition: transform .25s cubic-bezier(.2,.9,.2,1), box-shadow .25s;
user-select:none;
touch-action: manipulation;
}

.mysteryButton:active { transform:scale(.98); }

/* pulsing */
.pulse {
animation: pulseGlow 2.2s infinite ease-in-out;
}
@keyframes pulseGlow {
0% { box-shadow: 0 10px 30px rgba(120,60,200,0.18); transform:translateY(0) scale(1); }
50% { box-shadow: 0 24px 70px rgba(120,60,200,0.30); transform:translateY(-6px) scale(1.03); }
100% { box-shadow: 0 10px 30px rgba(120,60,200,0.18); transform:translateY(0) scale(1); }
}

/* smaller controls (Continue, Yes/No) */
.controlRow {
margin-top:20px;
display:flex;
gap:12px;
align-items:center;
justify-content:center;
pointer-events:auto;
}

.btn {
background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
border:1px solid rgba(255,255,255,0.06);
padding: 12px 22px;
border-radius:14px;
color:#fff;
font-size:16px;
cursor:pointer;
min-width:120px;
box-shadow: 0 8px 28px rgba(0,0,0,0.5);
transition: transform .12s, box-shadow .12s;
touch-action: manipulation;
}

.btn:active { transform: translateY(2px) scale(.995); }

.bigAction {
font-size:18px;
padding:14px 28px;
border-radius:26px;
min-width:160px;
}

/* poem box */
.poemBox {
margin-top:26px;
pointer-events:none;
max-width:760px;
margin-left:auto;
margin-right:auto;
background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));
border-radius: 12px;
padding: 18px 22px;
box-shadow: 0 12px 30px rgba(40,10,60,0.35);
backdrop-filter: blur(6px) saturate(120%);
opacity:0.98;
}

.poemLine {
font-size: clamp(16px,2.4vw,20px);
line-height:1.45;
color: #efeef8;
min-height:2.2em;
margin:6px 0;
white-space:pre-wrap;
overflow:hidden;
}

/* final proposal overlay */
.proposalOverlay {
position:absolute;
inset:0;
z-index:20;
display:flex;
align-items:center;
justify-content:center;
pointer-events:none;
opacity:0;
transition: opacity .8s ease;
}

.proposalCard {
pointer-events:auto;
background: linear-gradient(180deg, rgba(10,6,18,0.75), rgba(10,6,18,0.6));
border-radius:18px;
padding:26px;
text-align:center;
border:1px solid rgba(255,255,255,0.05);
box-shadow: 0 30px 80px rgba(20,8,40,0.6);
width:min(720px,92%);
}
.proposalText {
font-size: clamp(18px,3.8vw,28px);
margin-bottom:18px;
}
.yesNoRow { display:flex; gap:14px; justify-content:center; }

/* small helper */
.sr-only { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }

/* ribbon/bouquet container */
#bouquetCanvas {
position:absolute;
z-index:15;
inset:0;
pointer-events:none;
}

/* petal rain */
#petalCanvas {
position:absolute;
inset:0;
z-index:22;
pointer-events:none;
}

/* fallback continue shown if something breaks */
.fallback {
margin-top:18px;
display:inline-block;
pointer-events:auto;
font-size:14px;
opacity:0.95;
}

/* playful dodge animation for NO button */
.dodged {
transform: translateX(18px) translateY(-6px) scale(1.02);
transition: transform .18s cubic-bezier(.2,.9,.3,1);
}

/* small tip text */
.tip {
margin-top:12px;
font-size:13px;
color:rgba(255,255,255,0.65);
}

/* breathing light background for poem */
.breath {
position:absolute;
inset:0;
z-index:5;
pointer-events:none;
mix-blend-mode: screen;
opacity:0.35;
background: radial-gradient(circle at 50% 40%, rgba(200,120,255,0.08), transparent 12%),
radial-gradient(circle at 20% 70%, rgba(255,160,180,0.04), transparent 10%);
filter: blur(36px);
animation: breathe 6s ease-in-out infinite;
}
@keyframes breathe {
0% { transform: scale(1); opacity:0.28; }
50% { transform: scale(1.04); opacity:0.42; }
100% { transform: scale(1); opacity:0.28; }
}

/* responsive adjustments */
@media (max-width:520px) {
.mysteryButton { border-radius:18px; padding:14px 18px; font-size:18px; }
.poemLine { font-size:16px; }
.centerText { font-size:16px; }
} </style>

</head>
<body>
<div id="app" aria-live="polite">
  <canvas id="mainCanvas"></canvas>        <!-- used for starfield + tulip garden -->
  <canvas id="bouquetCanvas"></canvas>     <!-- used for bouquet flight and ribbon -->
  <canvas id="petalCanvas"></canvas>       <!-- used for petal rain -->
  <div class="fog" aria-hidden="true"></div>

  <div class="ui" id="ui">
    <div class="centerText" id="introText">This isnâ€™t a normal websiteâ€¦</div>

```
<div id="introControls" style="margin-top:22px;">
  <button id="tapBtn" class="mysteryButton pulse" aria-label="Tap me to continue">Tap Me</button>
  <div style="height:6px"></div>
  <div class="fallback" id="fallbackContinue" style="display:none;">
    <button id="fallbackBtn" class="btn">Continue</button>
  </div>
</div>

<!-- Tulip scene controls -->
<div id="tulipControls" style="display:none;">
  <div class="controlRow">
    <button id="continuePoem" class="btn bigAction" style="pointer-events:auto;">Continue</button>
  </div>
</div>

<!-- Poem scene -->
<div id="poemScene" style="display:none;">
  <div class="breath" aria-hidden="true"></div>
  <div class="poemBox" id="poemBox" aria-live="polite">
    <div id="poemLine1" class="poemLine"></div>
    <div id="poemLine2" class="poemLine"></div>
  </div>
  <div class="controlRow" style="margin-top:12px;">
    <button id="nextPoemBtn" class="btn bigAction" style="pointer-events:auto;">Next</button>
  </div>
</div>

<!-- Build up and bouquet controls -->
<div id="buildControls" style="display:none;">
  <div class="controlRow">
    <button id="oneLast" class="btn bigAction" style="pointer-events:auto;">One Last Thingâ€¦</button>
  </div>
</div>

<!-- proposal overlay -->
<div class="proposalOverlay" id="proposalOverlay" role="dialog" aria-modal="true" style="display:flex;">
  <div class="proposalCard" id="proposalCard" style="display:none;">
    <div class="proposalText" id="proposalText">Will you be my universe? ðŸ’«</div>
    <div class="yesNoRow">
      <button id="yesBtn" class="btn bigAction" style="background:linear-gradient(180deg,#ffecf8,#ffdff2); color:#3b0b2e;">YES</button>
      <button id="noBtn" class="btn bigAction" style="background:linear-gradient(180deg,#1a1a1a,#0e0c12); color:#fff;">NO</button>
    </div>
    <div class="tip" style="margin-top:12px;">(Tip: be sincere)</div>
  </div>
</div>
```

  </div>
</div>

<script>
/*
  Romantic Proposal Single File App
  - Scenes: Intro (starfield) -> Tulip Garden -> Poem -> Build Up -> Bouquet -> Proposal
  - Uses canvas for visuals and WebAudio API for synthetic sounds
  - Heavy comments, modular design, safety wrappers to avoid freezing
*/

/* Wrap entire app in an IIFE to avoid polluting global scope */
(function(){
  'use strict';

  /* ---------- Minimal state encapsulation ---------- */
  const App = {
    canvas:null,
    ctx:null,
    bouquetCanvas:null,
    bouquetCtx:null,
    petalCanvas:null,
    petalCtx:null,
    width:0, height:0,
    devicePixelRatio: Math.min(window.devicePixelRatio || 1, 2),
    scene:'intro', // intro, tulips, poem, build, bouquet, proposal
    rafId: null,
    audio: null,
    audioCtx: null,
    audioNodes: {},
    autoAdvanceTimer: null,
    lastInteraction: Date.now(),
    poemLines: [],
    poemIndex: 0
  };

  /* ---------- UI elements ---------- */
  const el = {
    app: document.getElementById('app'),
    canvas: document.getElementById('mainCanvas'),
    bouquetCanvas: document.getElementById('bouquetCanvas'),
    petalCanvas: document.getElementById('petalCanvas'),
    introText: document.getElementById('introText'),
    tapBtn: document.getElementById('tapBtn'),
    fallbackContinue: document.getElementById('fallbackContinue'),
    fallbackBtn: document.getElementById('fallbackBtn'),
    tulipControls: document.getElementById('tulipControls'),
    continuePoem: document.getElementById('continuePoem'),
    poemScene: document.getElementById('poemScene'),
    poemLine1: document.getElementById('poemLine1'),
    poemLine2: document.getElementById('poemLine2'),
    nextPoemBtn: document.getElementById('nextPoemBtn'),
    buildControls: document.getElementById('buildControls'),
    oneLast: document.getElementById('oneLast'),
    proposalOverlay: document.getElementById('proposalOverlay'),
    proposalCard: document.getElementById('proposalCard'),
    yesBtn: document.getElementById('yesBtn'),
    noBtn: document.getElementById('noBtn'),
    poemBox: document.getElementById('poemBox'),
  };

  /* ---------- Safely create AudioContext on first interaction ---------- */
  function initAudio(){
    try{
      if(App.audioCtx) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      App.audioCtx = new AudioContext();
      // master gain
      const master = App.audioCtx.createGain();
      master.gain.value = 0.9;
      master.connect(App.audioCtx.destination);
      App.audioNodes.master = master;

      // setup ambient wind loop
      setupAmbientWind();

      // heartbeat bass
      setupHeartbeatBass();

      // whoosh (one-shot generator)
      // chime generator will be triggered when user says YES
    }catch(e){
      console.warn('Audio init failed', e);
    }
  }

  /* ---------- Ambient wind: looping filtered noise ---------- */
  function setupAmbientWind(){
    try{
      const ctx = App.audioCtx;
      const bufferSize = 2 * ctx.sampleRate; // 2s buffer
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // fill with filtered noise (pink-ish)
      for(let i=0;i<bufferSize;i++){
        const white = (Math.random()*2-1);
        // simple low-pass smoothing for pink-ish noise
        data[i] = (white + (i?data[i-1]:0)*0.9) * 0.6;
      }

      const source = ctx.createBufferSource();
      source.loop = true;
      source.buffer = buffer;

      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 900 + Math.random()*400;

      const windGain = ctx.createGain();
      windGain.gain.value = 0.12;

      source.connect(filter);
      filter.connect(windGain);
      windGain.connect(App.audioNodes.master);

      source.start(0);
      App.audioNodes.wind = { source, filter, gain: windGain };
    }catch(e){
      console.warn('Ambient wind setup error', e);
    }
  }

  /* ---------- Heartbeat bass: slow low-frequency pulse ---------- */
  function setupHeartbeatBass(){
    try{
      const ctx = App.audioCtx;
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 36;

      const gain = ctx.createGain();
      gain.gain.value = 0.0; // start muted

      osc.connect(gain);
      gain.connect(App.audioNodes.master);
      osc.start();

      // store nodes and an interval controller
      App.audioNodes.heartbeat = { osc, gain };

      // start gentle pulsing
      // use WebAudio timing for smoothness
      const pulse = () => {
        const now = ctx.currentTime;
        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(0.02, now);
        gain.gain.exponentialRampToValueAtTime(0.8, now + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.02, now + 0.9);
      };
      // run at ~60-80 bpm (slow)
      App.audioNodes.heartbeat.interval = setInterval(pulse, 900); // ~66 bpm
      pulse();
    }catch(e){
      console.warn('Heartbeat setup error', e);
    }
  }

  /* ---------- Whoosh sound: one-shot filtered noise ---------- */
  function playWhoosh(){
    try{
      const ctx = App.audioCtx;
      const bufferSize = ctx.sampleRate * 0.4;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){
        data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize*0.9));
      }
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1200;
      const gain = ctx.createGain();
      gain.gain.value = 0.9;
      src.connect(filter);
      filter.connect(gain);
      gain.connect(App.audioNodes.master);
      src.start();
      // sweep
      filter.frequency.setValueAtTime(4000, ctx.currentTime);
      filter.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.38);
    }catch(e){
      console.warn('Whoosh error', e);
    }
  }

  /* ---------- Romantic chime for YES: harmonic bells ---------- */
  function playChime(){
    try{
      const ctx = App.audioCtx;
      const master = App.audioNodes.master;
      const now = ctx.currentTime;
      const baseFreq = 440; // A4 as base-ish, will detune for warmth
      const freqs = [baseFreq*1.0, baseFreq*1.5, baseFreq*2.02, baseFreq*2.99];

      freqs.forEach((f, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = f * (1 + (Math.random()-0.5)*0.01);
        const gain = ctx.createGain();
        gain.gain.value = 0.0;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 7200 - i*800;

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(master);

        gain.gain.setValueAtTime(0.0, now);
        gain.gain.linearRampToValueAtTime(0.18/(i+1), now + 0.02 + i*0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 3 + i*0.4);

        osc.start(now + i*0.02);
        osc.stop(now + 4 + i*0.5);
      });

      // gentle bell overtone via FM-ish sharp oscillator
      const gliss = ctx.createOscillator();
      gliss.type = 'triangle';
      gliss.frequency.value = baseFreq*0.5;
      const gGain = ctx.createGain();
      gGain.gain.value = 0.0;
      gliss.connect(gGain);
      gGain.connect(master);
      gGain.gain.setValueAtTime(0.0, now);
      gGain.gain.linearRampToValueAtTime(0.06, now+0.05);
      gGain.gain.exponentialRampToValueAtTime(0.0001, now+3.2);
      gliss.start(now);
      gliss.stop(now+3.6);
    }catch(e){
      console.warn('Chime error', e);
    }
  }

  /* ---------- Utility: clamp ---------- */
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  /* ---------- Canvas initialization and resize ---------- */
  function setupCanvas(){
    App.canvas = el.canvas;
    App.ctx = App.canvas.getContext('2d',{ alpha:true, willReadFrequently:false });
    App.bouquetCanvas = el.bouquetCanvas;
    App.bouquetCtx = App.bouquetCanvas.getContext('2d');
    App.petalCanvas = el.petalCanvas;
    App.petalCtx = App.petalCanvas.getContext('2d');

    function resize(){
      try{
        App.width = Math.max(document.documentElement.clientWidth || 300, 300);
        App.height = Math.max(document.documentElement.clientHeight || 300, 300);
        const ratio = App.devicePixelRatio;
        [App.canvas, App.bouquetCanvas, App.petalCanvas].forEach(c => {
          c.width = Math.floor(App.width * ratio);
          c.height = Math.floor(App.height * ratio);
          c.style.width = App.width + 'px';
          c.style.height = App.height + 'px';
          const ctx = c.getContext('2d');
          ctx.setTransform(ratio,0,0,ratio,0,0);
        });
      }catch(e){
        console.warn('Resize error', e);
      }
    }
    window.addEventListener('resize', resize);
    resize();
  }

  /* ---------- Starfield (intro) ---------- */
  const Starfield = (function(){
    let stars = [];
    let starCount = 160;
    let t = 0;
    function init(){
      stars = [];
      for(let i=0;i<starCount;i++){
        stars.push({
          x: Math.random()*App.width,
          y: Math.random()*App.height,
          r: Math.random()*1.4 + 0.3,
          ox: Math.random()*App.width,
          oy: Math.random()*App.height,
          phase: Math.random()*Math.PI*2,
          speed: 0.2 + Math.random()*0.6,
          hue: 250 + Math.random()*80
        });
      }
    }
    function draw(dt){
      try{
        const ctx = App.ctx;
        t += dt;
        // fade background to deep black with purple tinge
        ctx.clearRect(0,0,App.width,App.height);
        const g = ctx.createLinearGradient(0,0,0,App.height);
        g.addColorStop(0,'#030007');
        g.addColorStop(1,'#050012');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,App.width,App.height);

        // subtle moving nebula
        const ng = ctx.createRadialGradient(App.width*0.2, App.height*0.15, 0, App.width*0.2, App.height*0.15, Math.max(App.width,App.height)*0.8);
        ng.addColorStop(0, 'rgba(120,60,200,0.09)');
        ng.addColorStop(0.65, 'rgba(60,20,80,0.02)');
        ng.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle = ng;
        ctx.fillRect(0,0,App.width,App.height);

        // stars
        for(let s of stars){
          // twinkle
          const tw = (Math.sin(t*s.phase*0.25 + s.phase) + 1) * 0.5;
          const size = s.r * (0.85 + 0.6*tw);
          ctx.beginPath();
          const hue = s.hue + Math.sin(t*0.002 + s.phase)*6;
          ctx.fillStyle = `hsl(${hue} 100% ${clamp(60+tw*30,50,92)}%)`;
          ctx.globalAlpha = 0.6 + tw*0.4;
          ctx.arc(s.x + Math.sin(t*s.speed*0.0008 + s.phase)*6, s.y + Math.cos(t*s.speed*0.0009 + s.phase)*3, size, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }catch(e){
        console.warn('Starfield draw error', e);
      }
    }
    return { init, draw };
  })();

  /* ---------- Tulip Garden ---------- */
  const TulipGarden = (function(){
    let tulips = [];
    let bounds = { w:0, h:0 };
    function randomRange(a,b){ return a + Math.random()*(b-a); }

    function generate(count){
      tulips = [];
      bounds.w = App.width;
      bounds.h = App.height;
      for(let i=0;i<count;i++){
        const depth = Math.random(); // 0 far, 1 near
        const x = Math.random() * bounds.w;
        // place more near bottom to simulate ground
        const y = bounds.h * (0.45 + depth*0.5 + Math.random()*0.05);
        const scale = 0.6 + depth*1.8 + Math.random()*0.6;
        const hue = 320 + Math.random()*70; // pinkish to purple/reds
        const size = 18 + depth*42 + Math.random()*18;
        const swayPhase = Math.random()*Math.PI*2;
        const swaySpeed = 0.0006 + Math.random()*0.0012;
        tulips.push({
          x,y,depth,scale,hue,size,swayPhase,swaySpeed,
          stemCurviness: 0.08 + Math.random()*0.2,
          petals: makePetalLayers(hue, size),
          isFront: depth > 0.6
        });
      }

      // sort by depth for painter's algorithm
      tulips.sort((a,b)=>a.depth - b.depth);
    }

    // create layered petal definitions
    function makePetalLayers(hue, size){
      // petals as objects: radius, offset angle, color stops
      const primary = { r: size*0.6, layer:0, hue, stops: [{pos:0, color:'rgba(255,230,240,1)'},{pos:1, color:`hsl(${hue},85%,48%)`} ]};
      const inner = { r: size*0.4, layer:1, hue, stops: [{pos:0, color:'rgba(255,255,255,0.95)'},{pos:1, color:`hsl(${hue},85%,62%)`}]};
      const shadow = { r: size*0.7, layer:-1, hue, stops: [{pos:0, color:'rgba(10,6,20,0.0)'},{pos:1, color:'rgba(6,2,14,0.35)'}] };
      return [shadow, primary, inner];
    }

    // draw a single tulip with bezier stem, layered petals using radial gradients
    function drawTulip(ctx, t, tulip){
      try{
        const sway = Math.sin(t * tulip.swaySpeed + tulip.swayPhase) * (6 + (1 - tulip.depth)*2);
        // stem control points
        const stemTopX = tulip.x + sway;
        const stemTopY = tulip.y;
        const baseX = tulip.x + (Math.random()-0.5)*12;
        const baseY = App.height + 40;
        ctx.lineWidth = clamp(2.0 * tulip.scale, 0.8, 6.0);
        ctx.strokeStyle = `rgba(40,80,30,${0.85 - tulip.depth*0.6})`;
        ctx.beginPath();
        const cp1x = baseX + (stemTopX - baseX) * tulip.stemCurviness + (Math.random()-0.5)*30;
        const cp1y = baseY - (App.height - stemTopY)*0.45;
        const cp2x = baseX + (stemTopX - baseX) * (0.6 + tulip.stemCurviness) + (Math.random()-0.5)*30;
        const cp2y = baseY - (App.height - stemTopY)*0.75;
        ctx.moveTo(baseX, baseY);
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, stemTopX, stemTopY);
        ctx.stroke();

        // soft shadow under flower (elliptical)
        const shadowRad = 8 + (1 - tulip.depth) * 18;
        ctx.beginPath();
        ctx.ellipse(stemTopX + 6, stemTopY + 8 + (1 - tulip.depth)*10, shadowRad, shadowRad*0.45, 0, 0, Math.PI*2);
        const shgr = ctx.createRadialGradient(stemTopX+6, stemTopY+8,1, stemTopX+6, stemTopY+8, shadowRad*1.6);
        shgr.addColorStop(0,'rgba(0,0,0,0.24)');
        shgr.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle = shgr;
        ctx.fill();

        // petals: layered radial gradients + arcs
        const cx = stemTopX;
        const cy = stemTopY;
        for(let p of tulip.petals){
          const grad = ctx.createRadialGradient(cx, cy - p.r*0.2, p.r*0.05, cx, cy, p.r*1.2);
          for(let s of p.stops){ grad.addColorStop(s.pos, s.color); }
          ctx.fillStyle = grad;
          ctx.beginPath();
          // draw slightly rotated petal shapes via bezier arcs
          const petalW = p.r * (1.2 - tulip.depth*0.35);
          const petalH = p.r * (1.0 - tulip.depth*0.2);
          ctx.ellipse(cx, cy - (p.layer*2), petalW, petalH, Math.sin(tulip.swayPhase + p.layer)*0.45, 0, Math.PI*2);
          ctx.fill();
        }

        // center glow
        const glow = ctx.createRadialGradient(cx,cy,0, cx,cy, 28);
        glow.addColorStop(0,'rgba(255,255,255,0.18)');
        glow.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(cx,cy,18 * (1 - tulip.depth*0.3),0,Math.PI*2);
        ctx.fill();

      }catch(e){
        console.warn('drawTulip error', e);
      }
    }

    function draw(dt){
      try{
        const ctx = App.ctx;
        // clear lower half as ground
        ctx.save();
        // subtle gradient ground
        const g = ctx.createLinearGradient(0,App.height*0.45,0,App.height);
        g.addColorStop(0,'rgba(10,6,12,0.0)');
        g.addColorStop(1,'rgba(5,3,6,0.6)');
        ctx.fillStyle = g;
        ctx.fillRect(0,App.height*0.45,App.width,App.height*0.55);

        // draw tulips by depth
        const t = Date.now();
        for(let tulip of tulips){
          drawTulip(ctx, t, tulip);
        }
        ctx.restore();
      }catch(e){
        console.warn('Tulip draw error', e);
      }
    }

    // detach tulips into flying bouquet: pick front ones and animate flight
    function detachIntoBouquet(targetX, targetY){
      const bouquetTulips = tulips.filter(t=>t.isFront).slice(-8); // pick some front ones
      return bouquetTulips.map((t, i) => ({
        x: t.x, y: t.y,
        vx: (targetX - t.x) / 600 + (Math.random()-0.5)*0.5,
        vy: (targetY - t.y) / 800 + (Math.random()*-0.2),
        r: t.size, hue: t.hue, phase: t.swayPhase, scale: t.scale,
        offset: i,
      }));
    }

    return { generate, draw, detachIntoBouquet };
  })();

  /* ---------- Particle system for button disintegration ---------- */
  const Particles = (function(){
    let parts = [];
    function spawn(x,y, color, count=48){
      for(let i=0;i<count;i++){
        parts.push({
          x, y,
          vx: (Math.random()-0.5)*6,
          vy: (Math.random()-0.8)*-6,
          rot: Math.random()*Math.PI*2,
          vr: (Math.random()-0.5)*0.16,
          life: 0.8 + Math.random()*1.2,
          age:0,
          size: 2 + Math.random()*6,
          color: color || `hsl(${320 + Math.random()*50} 90% ${40+Math.random()*30}%)`
        });
      }
    }
    function updateAndDraw(ctx, dt){
      try{
        if(parts.length===0) return;
        for(let i=parts.length-1;i>=0;i--){
          const p = parts[i];
          p.age += dt;
          if(p.age > p.life){ parts.splice(i,1); continue; }
          p.vy += 9.8 * dt; // gravity
          p.x += p.vx * (60*dt);
          p.y += p.vy * (60*dt);
          p.rot += p.vr;
          const alpha = Math.max(0,1 - p.age / p.life);
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.ellipse(0,0, p.size * 0.6, p.size * 0.9, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }catch(e){
        console.warn('Particles draw error', e);
      }
    }
    return { spawn, updateAndDraw };
  })();

  /* ---------- Bouquet flight + ribbon animation ---------- */
  const Bouquet = (function(){
    let flowers = [];
    let ribbon = null;
    let flying = false;
    function start(flowerDefs, targetX, targetY){
      try{
        flying = true;
        flowers = flowerDefs.map((f,i)=>({
          x: f.x, y: f.y,
          vx: f.vx, vy: f.vy,
          r: f.r, hue:f.hue, offset: f.offset,
          life: 3.6 + Math.random()*0.8,
          age:0
        }));
        ribbon = { x: targetX, y: targetY, t:0 };
      }catch(e){
        console.warn('Bouquet start error', e);
      }
    }

    function updateAndDraw(ctx, dt){
      try{
        if(!flying) return;
        ctx.save();
        for(let i=flowers.length-1;i>=0;i--){
          const f = flowers[i];
          f.age += dt;
          if(f.age > f.life){ flowers.splice(i,1); continue; }
          // simple movement
          f.vy += 6 * dt;
          f.x += f.vx * (60*dt);
          f.y += f.vy * (60*dt);
          // draw flower as small circle with tiny petals
          const px = f.x;
          const py = f.y;
          // stem tip small
          ctx.beginPath();
          ctx.fillStyle = `hsl(${f.hue} 80% 60%)`;
          ctx.arc(px,py, Math.max(4, f.r*0.18), 0, Math.PI*2);
          ctx.fill();
          ctx.save();
          ctx.translate(px,py);
          // small layers petals
          for(let p=0;p<5;p++){
            ctx.rotate((Math.PI*2/5));
            ctx.beginPath();
            ctx.ellipse(8,0, f.r*0.18, f.r*0.34, 0,0,Math.PI*2);
            ctx.fillStyle = `rgba(255,240,245,${0.85 - p*0.08})`;
            ctx.fill();
          }
          ctx.restore();
        }
        // draw ribbon around target point as animated loop
        if(ribbon){
          ribbon.t += dt * 1.6;
          const tx = ribbon.x;
          const ty = ribbon.y;
          // draw ephemeral ribbon swirl
          for(let i=0;i<4;i++){
            ctx.beginPath();
            const r = 18 + i*8 + Math.sin(ribbon.t*1.6 + i)*6;
            ctx.ellipse(tx, ty + 6, r, r*0.28, Math.sin(ribbon.t + i)*0.4, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255,220,240,${0.14 - i*0.02})`;
            ctx.lineWidth = 2.2;
            ctx.stroke();
          }
          // small bow
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255,200,230,0.95)';
          ctx.ellipse(tx-6, ty-2, 10,6, -0.6,0,Math.PI*2);
          ctx.ellipse(tx+6, ty-2, 10,6, 0.6,0,Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.fillStyle = 'rgba(220,90,140,1)';
          ctx.arc(tx, ty+6, 4, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }catch(e){
        console.warn('Bouquet draw error', e);
      }
    }

    function isDone(){ return flowers.length === 0; }

    return { start, updateAndDraw, isDone, flying: ()=>flying };
  })();

  /* ---------- Petal rain ---------- */
  const PetalRain = (function(){
    let petals = [];
    function start(count=60){
      petals = [];
      for(let i=0;i<count;i++){
        petals.push({
          x: Math.random()*App.width,
          y: -Math.random()*App.height,
          vx: (Math.random()-0.5)*0.6,
          vy: 0.6 + Math.random()*1.6,
          rot: Math.random()*Math.PI*2,
          vr: (Math.random()-0.5)*0.05,
          size: 8 + Math.random()*18,
          hue: 320 + Math.random()*60
        });
      }
    }
    function updateAndDraw(ctx, dt){
      try{
        ctx.save();
        for(let i=petals.length-1;i>=0;i--){
          const p = petals[i];
          p.x += p.vx * (80*dt);
          p.y += p.vy * (80*dt);
          p.rot += p.vr;
          if(p.y > App.height + 40){ petals.splice(i,1); continue; }
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          // petal shape
          ctx.beginPath();
          ctx.ellipse(0,0, p.size*0.6, p.size, 0,0,Math.PI*2);
          const g = ctx.createLinearGradient(-p.size, -p.size, p.size, p.size);
          g.addColorStop(0, 'rgba(255,255,255,0.95)');
          g.addColorStop(1, `hsl(${p.hue} 85% 60%)`);
          ctx.fillStyle = g;
          ctx.globalAlpha = 0.95;
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }catch(e){
        console.warn('Petal draw error', e);
      }
    }
    return { start, updateAndDraw };
  })();

  /* ---------- Poem handling (two lines at a time with typewriter) ---------- */
  const Poem = (function(){
    function initPoem(){
      // exact poem as provided (preserve punctuation and line breaks)
      const poemText = `Sometimes I think I fell for you
before I even learned how falling works.
My words trip over themselves..
And as I said earlier.. you're like a Luminous Singularity
which's parallel yet coincidently intersecting...
Like constellations shuffled in a hurry...
Orion losing its belt..
Cassiopeia sitting upside down..
and whole sky is asking "Why is she the only one shining this bright?"
And I swear ... 
every time i try to explain what you mean to me.. I fumble..I'm scared...
and my heart chooses Your tulips instead of sentences 
petals arranged in a wrong order.. yet beautiful..
Colors mixing where they shouldn't yet somehow looking eternal..
and it's strange how You make the universe feel like a misprinted bouquet..
Galaxies scribbled over with your name..
planets orbiting a little too close..
a pull like the Black hole..
Like they too forgot their distance.
And me? I'm jst a boy holding a bouquet thinking maybe if I say it wrong enough times
you Might hear the truth hidden between the mistakes
That in every star's cold shimmer and every tulip's quite softness
i keep finding you 
not perfectly..
not clearly 
but completely...`;
      App.poemLines = poemText.split('\n');
      App.poemIndex = 0;
    }

    // Show two lines at a time with typewriter + fade
    let typing = false;
    function showNextPair(){
      if(typing) return;
      typing = true;
      const i = App.poemIndex;
      const line1 = App.poemLines[i] || '';
      const line2 = App.poemLines[i+1] || '';
      App.poemIndex += 2;

      // clear
      el.poemLine1.textContent = '';
      el.poemLine2.textContent = '';
      el.poemScene.style.display = 'block';
      el.poemBox.scrollIntoView({behavior:'smooth', block:'center'});

      // typewriter helper for each line
      function typeText(element, text, speed){
        return new Promise(resolve=>{
          let idx = 0;
          const timer = setInterval(()=>{
            try{
              idx++;
              element.textContent = text.slice(0, idx);
              if(idx >= text.length){
                clearInterval(timer);
                resolve();
              }
            }catch(e){
              clearInterval(timer);
              resolve();
            }
          }, speed);
        });
      }

      // comfortable reading delay
      (async function(){
        try{
          await typeText(el.poemLine1, line1, clamp(14 + line1.length/8, 8, 28));
          await new Promise(r=>setTimeout(r, 250));
          await typeText(el.poemLine2, line2, clamp(12 + line2.length/9, 7, 26));
          // after showing, enable Next or auto-advance after short delay
          typing = false;
          // if reached end, trigger build up UI after small delay
          if(App.poemIndex >= App.poemLines.length){
            setTimeout(()=>{ transitionToBuildUp(); }, 1100);
          }
        }catch(e){
          typing=false;
        }
      })();
    }

    return { initPoem, showNextPair };
  })();

  /* ---------- Scene control flow ---------- */
  function goToTulips(){
    try{
      App.scene = 'tulips';
      // clear starfield and draw garden
      // generate tulips based on size
      TulipGarden.generate(Math.floor(App.width/24) + 18);
      // show controls
      el.introText.style.opacity = 0;
      el.tapBtn.style.display = 'none';
      el.fallbackContinue.style.display = 'none';
      el.tulipControls.style.display = 'block';
      // whoosh audio and slight zoom camera via scale
      safePlay(() => {
        initAudio();
        playWhoosh();
      });
    }catch(e){
      console.warn('goToTulips error', e);
    }
  }

  function transitionToPoem(){
    try{
      App.scene = 'poem';
      el.tulipControls.style.display = 'none';
      el.poemScene.style.display = 'block';
      Poem.initPoem();
      Poem.showNextPair();
      // small whoosh
      safePlay(()=>playWhoosh());
    }catch(e){
      console.warn('transitionToPoem error', e);
    }
  }

  function transitionToBuildUp(){
    try{
      App.scene = 'build';
      el.poemScene.style.display = 'none';
      el.buildControls.style.display = 'block';
      // slight whoosh
      safePlay(()=>playWhoosh());
    }catch(e){
      console.warn('transitionToBuildUp error', e);
    }
  }

  function startBouquetSequence(){
    try{
      App.scene = 'bouquet';
      el.buildControls.style.display = 'none';
      // create detachable tulips and start bouquet flight toward center
      const targetX = App.width/2;
      const targetY = App.height*0.38;
      const defs = TulipGarden.detachIntoBouquet(targetX, targetY);
      Bouquet.start(defs, targetX, targetY);
      safePlay(()=>playWhoosh());
      // after bouquet flight completes, show proposal
      (function checkDone(){
        if(Bouquet.isDone()){
          setTimeout(()=>showProposal(), 600);
        } else {
          setTimeout(checkDone, 400);
        }
      })();
    }catch(e){
      console.warn('startBouquetSequence error', e);
    }
  }

  function showProposal(){
    try{
      App.scene = 'proposal';
      el.proposalOverlay.style.pointerEvents = 'auto';
      el.proposalOverlay.style.display = 'flex';
      setTimeout(()=>{ el.proposalOverlay.style.opacity = 1; el.proposalCard.style.display = 'block'; }, 50);
      // subtle heartbeat pick-up
      if(App.audioNodes && App.audioNodes.heartbeat && App.audioCtx){
        // increase heartbeat intensity briefly
        const g = App.audioNodes.heartbeat.gain;
        const ctx = App.audioCtx;
        const now = ctx.currentTime;
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0.02, now);
        g.gain.linearRampToValueAtTime(0.95, now+0.6);
        g.gain.exponentialRampToValueAtTime(0.02, now+3.5);
      }
    }catch(e){
      console.warn('showProposal error', e);
    }
  }

  /* ---------- Safe audio play helper (init on user gesture) ---------- */
  function safePlay(fn){
    try{
      if(!App.audioCtx || App.audioCtx.state === 'suspended'){
        // some browsers require resume on user gesture; attempt resume
        try{ App.audioCtx && App.audioCtx.resume && App.audioCtx.resume(); }catch(e){}
      }
      fn && fn();
    }catch(e){
      console.warn('safePlay error', e);
    }
  }

  /* ---------- Render loop ---------- */
  let lastTime = performance.now();
  function loop(now){
    try{
      const dt = Math.min(0.06, (now - lastTime) / 1000); // clamp dt
      lastTime = now;

      // clear entire main canvas
      App.ctx.clearRect(0,0,App.width,App.height);

      // Depending on scene, draw appropriate layers
      if(App.scene === 'intro'){
        Starfield.draw(now);
      } else {
        // draw starfield background but more dim when tulips
        Starfield.draw(now);
        if(App.scene === 'tulips' || App.scene === 'poem' || App.scene === 'build' || App.scene === 'bouquet' || App.scene === 'proposal'){
          TulipGarden.draw();
        }
      }

      // draw particles on main canvas (disintegration)
      Particles.updateAndDraw(App.ctx, dt);

      // bouquet draws on bouquetCanvas
      App.bouquetCtx.clearRect(0,0,App.width,App.height);
      Bouquet.updateAndDraw(App.bouquetCtx, dt);

      // petal canvas
      App.petalCtx.clearRect(0,0,App.width,App.height);
      PetalRain.updateAndDraw(App.petalCtx, dt);

      App.rafId = requestAnimationFrame(loop);
    }catch(e){
      console.warn('Main loop error', e);
      App.rafId = requestAnimationFrame(loop);
    }
  }

  /* ---------- Interaction wiring ---------- */
  function bindEvents(){
    // primary interaction - tap button
    function userInteracted(){
      App.lastInteraction = Date.now();
      // resume audio on interaction
      try{ initAudio(); }catch(e){}
    }

    el.tapBtn.addEventListener('click', (ev)=>{
      try{
        userInteracted();
        // disintegrate button into particles, zoom camera effect (simulate with subtle scale)
        const rect = el.tapBtn.getBoundingClientRect();
        const x = rect.left + rect.width/2;
        const y = rect.top + rect.height/2;
        // spawn particles
        Particles.spawn(x, y, null, 80);
        // zoom effect via CSS scale on canvas container
        el.app.animate([{transform:'scale(1)'}, {transform:'scale(1.03)'}], {duration:420, direction:'alternate', iterations:2, easing:'ease-out'});
        // hide text and move to tulips after short delay
        setTimeout(goToTulips, 520);
      }catch(e){
        console.warn(e);
      }
    }, {passive:true});

    // fallback continue
    el.fallbackBtn.addEventListener('click', ()=>{ userInteracted(); goToTulips(); });

    // Continue to poem
    el.continuePoem.addEventListener('click', ()=>{ userInteracted(); transitionToPoem(); }, {passive:true});
    el.nextPoemBtn.addEventListener('click', ()=>{ userInteracted(); Poem.showNextPair(); }, {passive:true});

    // One last thing -> bouquet
    el.oneLast.addEventListener('click', ()=>{ userInteracted(); startBouquetSequence(); }, {passive:true});

    // YES button
    el.yesBtn.addEventListener('click', ()=>{
      try{
        initAudio();
        playChime(); // romantic chime
        PetalRain.start(120);
        // final message overlay
        showFinalText("You were always my favorite galaxy ðŸŒ™ðŸŒ·");
        // gentle whoosh
        playWhoosh();
      }catch(e){
        console.warn('yes click error', e);
      }
    }, {passive:true});

    // NO button - playful dodge twice
    let dodgeCount = 0;
    el.noBtn.addEventListener('mouseenter', (ev)=>{
      try{
        if(dodgeCount < 2){
          dodgeCount++;
          el.noBtn.classList.add('dodged');
          setTimeout(()=>el.noBtn.classList.remove('dodged'), 420);
        }
      }catch(e){
        console.warn('no mouseenter error', e);
      }
    });
    // also touch handling for NO on mobile - touch will trigger dodge
    el.noBtn.addEventListener('touchstart', (ev)=>{
      try{
        ev.preventDefault();
        if(dodgeCount < 2){
          dodgeCount++;
          el.noBtn.classList.add('dodged');
          setTimeout(()=>el.noBtn.classList.remove('dodged'), 420);
        } else {
          // on third try, accept gracefully (in case user insists)
          el.yesBtn.click();
        }
      }catch(e){
        console.warn('no touch error', e);
      }
    }, {passive:false});

    // generic activity to reset auto-advance timer
    ['click','touchstart','keydown','mousemove','scroll'].forEach(evt=>{
      window.addEventListener(evt, ()=>{ App.lastInteraction = Date.now(); }, {passive:true});
    });
  }

  /* ---------- Final message sequence ---------- */
  function showFinalText(text){
    try{
      // hide proposal card content and show final text in same card
      el.proposalText.textContent = text;
      // disable buttons
      el.yesBtn.disabled = true;
      el.noBtn.disabled = true;
      // celebrate animation
      el.proposalCard.animate([{ transform:'translateY(0) scale(1)' }, {transform:'translateY(-6px) scale(1.02)'}], { duration: 700, direction: 'alternate', iterations: 2 });
    }catch(e){
      console.warn('showFinalText error', e);
    }
  }

  /* ---------- Auto-advance safety: if no input, continue after 10s for each scene ---------- */
  function setupAutoAdvance(){
    function check(){
      try{
        const since = Date.now() - App.lastInteraction;
        if(since > 10000){
          // auto-do something depending on scene
          if(App.scene === 'intro'){
            el.tapBtn.click();
          } else if(App.scene === 'tulips'){
            el.continuePoem.click();
          } else if(App.scene === 'poem'){
            el.nextPoemBtn.click();
          } else if(App.scene === 'build'){
            el.oneLast.click();
          } else if(App.scene === 'proposal'){
            // no auto accept; do nothing
          }
          App.lastInteraction = Date.now();
        }
      }catch(e){
        console.warn('autoAdvance error', e);
      } finally {
        setTimeout(check, 3500);
      }
    }
    setTimeout(check, 3500);
  }

  /* ---------- Initial intro reveal animations ---------- */
  function introReveal(){
    try{
      // fade in intro text and small flourish
      el.introText.style.transition = 'opacity 900ms ease, transform 900ms cubic-bezier(.2,.9,.2,1)';
      el.introText.style.opacity = 1;
      el.introText.style.transform = 'translateY(0)';
      // fallback continue visible after 6s in case of issues
      setTimeout(()=>{ el.fallbackContinue.style.display = 'block'; }, 6000);
    }catch(e){
      console.warn('introReveal error', e);
    }
  }

  /* ---------- Initialization ---------- */
  function init(){
    try{
      setupCanvas();
      bindEvents();
      Starfield.init();
      introReveal();
      lastTime = performance.now();
      App.rafId = requestAnimationFrame(loop);
      // show fallback Continue if scripts or animations fail to respond
      setTimeout(()=>{
        el.fallbackContinue.style.display = 'block';
      }, 8000);
      setupAutoAdvance();
      // small attempt to start audio on first user gesture
      window.addEventListener('click', initAudio, { once:true });
      window.addEventListener('touchstart', initAudio, { once:true });
    }catch(e){
      console.error('Init error', e);
    }
  }

  /* ---------- Safety wrapper to avoid frozen animations ---------- */
  function safe(fn){
    try{ fn(); }catch(e){ console.warn('safe wrapper error', e); }
  }

  /* ---------- Start app ---------- */
  init();

  /* ---------- Expose some safe helpers for internal use (not global) ---------- */
  // help debugging in console (not necessary but useful for dev)
  // window._app = App; // commented out to avoid polluting global
})();

</script>

</body>
</html>
